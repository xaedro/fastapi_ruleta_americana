<!-- index4.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Ruleta Americana - WebRTC P2P</title>
    <!-- Tu CSS de index3.html va aquí. No necesita cambios. -->
    <style>
        body { font-family: sans-serif; padding: 20px; }
        #main-container, #capture-controls { display: none; }
        #login-container { text-align: center; margin-top: 50px; }
        .video-container { width: 100%; max-width: 600px; background-color: #000; border: 1px solid #ccc; position: relative; }
        #live-stream { width: 100%; display: block; }
        .video-placeholder { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #888; font-size: 1.5em; text-align: center; }
    </style>
</head>
<body>
    <!-- Tu HTML de index3.html va aquí, con un cambio clave: -->
    <div id="login-container">
        <h1>Bienvenido a la Ruleta Americana</h1>
        <p>Por favor, ingresa tu nombre para continuar.</p>
        <form id="login-form"><input type="text" id="name-input" placeholder="Tu nombre" required><button type="submit">Ingresar</button></form>
    </div>
    <div id="main-container">
        <h1>Ruleta Americana (Stream en Vivo - WebRTC)</h1>
        <div class="video-container">
            <!-- CAMBIO: Usamos un <video> para WebRTC, no una <img> -->
            <video id="live-stream" autoplay playsinline></video>
            <div id="streamPlaceholder" class="video-placeholder">Esperando transmisión...</div>
        </div>
        <div id="capture-controls">
            <button id="startButton">INICIAR TRANSMISIÓN</button>
        </div>
        <!-- El resto de tu HTML para apuestas, etc. no cambia -->
    </div>

<script>
    // --- Referencias al DOM ---
    const loginContainer = document.getElementById('login-container');
    const mainContainer = document.getElementById('main-container');
    const loginForm = document.getElementById('login-form');
    const nameInput = document.getElementById('name-input');
    const startButton = document.getElementById('startButton');
    const captureControls = document.getElementById('capture-controls');
    const liveStreamVideo = document.getElementById('live-stream');
    const streamPlaceholder = document.getElementById('streamPlaceholder');
    
    // --- Estado Global y Configuración ---
    let userRole = "viewer";
    let isStreaming = false;
    let localStream; // Para el streamer
    let peerConnections = {}; // Streamer: guarda una conexión por cada espectador
    let peerConnection;     // Espectador: solo tiene una conexión con el streamer
	let ws = null; 
	
    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            {
              urls: 'turn:relay1.expressturn.com:3480',
              username: '000000002067441357',      // <-- ¡REEMPLAZA ESTO!
              credential: 'ZWtqCZGCwebs2UeE8c8ryeqBHN8=' // <-- ¡REEMPLAZA ESTO!
            }
        ]
    };
    
	
	
    // --- Lógica de la Aplicación ---
    loginForm.onsubmit = (event) => {
		event.preventDefault();
		const username = nameInput.value.trim();
		if (username) {
			// Solo intentamos conectar si no hay ya una conexión activa o conectando
			if (!ws || ws.readyState === WebSocket.CLOSED || ws.readyState === WebSocket.CLOSING) {
				connectWebSocket(username);
			} else {
				console.log("Ya se está intentando una conexión.");
			}
		} else {
			alert("Por favor, ingresa un nombre.");
		}
	};


    startButton.onclick = async () => {
        if (userRole === 'streamer' && !isStreaming) {
            try {
                localStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                isStreaming = true;
                startButton.disabled = true;
                startButton.textContent = "TRANSMITIENDO...";
                liveStreamVideo.srcObject = localStream; // El streamer ve su propio stream
                liveStreamVideo.muted = true;
                showStream();
                ws.send(JSON.stringify({ type: 'start_stream' }));

                localStream.getVideoTracks()[0].onended = () => {
                    ws.send(JSON.stringify({ type: 'stream_ended' }));
                };
            } catch (err) { console.error("Error al capturar pantalla:", err); }
        }
    };
    
    // --- Funciones de UI ---
    function showStream() {
        liveStreamVideo.style.visibility = 'visible';
        streamPlaceholder.style.display = 'none';
    }
    function showPlaceholder(message) {
        liveStreamVideo.style.visibility = 'hidden';
        streamPlaceholder.textContent = message;
        streamPlaceholder.style.display = 'block';
    }

    // --- Lógica de WebSocket ---
	function connectWebSocket(username) {
		console.log("Intentando conectar WebSocket...");
		
		const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
		const wsHost = window.location.host;
		ws = new WebSocket(`${wsProtocol}//${wsHost}/ws/users`);

		let heartbeatInterval;

		ws.onopen = () => {
			console.log("Conectado al servidor. WebSocket está OPEN.");
			ws.send(JSON.stringify({ type: "login", name: username }));

			heartbeatInterval = setInterval(() => {
				if (ws.readyState === WebSocket.OPEN) {
					ws.send(JSON.stringify({ type: 'ping' }));
				}
			}, 25000);
		};

		// En index4.html

	ws.onmessage = (event) => {
		console.log("RAW MESSAGE RECEIVED:", event.data);

		try {
			const data = JSON.parse(event.data);
			
			// Ignorar las respuestas del heartbeat (si las añadimos después)
			if (data.type === 'pong') {
				return;
			}

			switch (data.type) {
				case 'login_success':
					console.log("Procesando login_success. Rol:", data.role);
					userRole = data.role;
					loginContainer.style.display = 'none';
					mainContainer.style.display = 'block';
					if (userRole === 'streamer') {
						captureControls.style.display = 'block';
					}
					// Guardamos el nombre de usuario para usarlo en las apuestas, etc.
					currentUsername = nameInput.value.trim(); 
					nombreLogueadoElem.textContent = currentUsername;
					break;

				case 'stream_started':
					console.log("Recibido 'stream_started'. Rol actual:", userRole);
					showStream();
					if (userRole === 'viewer') {
						startViewing();
					}
					break;
				
				case 'stream_ended':
					console.log("Recibido 'stream_ended'.");
					isStreaming = false;
					showPlaceholder("La transmisión ha finalizado.");
					if (userRole === 'streamer') {
						startButton.disabled = false;
						startButton.textContent = "INICIAR TRANSMISIÓN";
						if (localStream) {
							localStream.getTracks().forEach(track => track.stop());
						}
						localStream = null;
						Object.values(peerConnections).forEach(pc => pc.close());
						peerConnections = {};
					} else {
						if (peerConnection) {
							peerConnection.close();
						}
						peerConnection = null;
						liveStreamVideo.srcObject = null;
					}
					break;

				// --- Casos de Señalización WebRTC ---
				case 'offer':
					if (userRole === 'streamer') {
						handleOffer(data.offer, data.from_id);
					}
					break;
				case 'answer':
					if (userRole === 'viewer') {
						handleAnswer(data.answer); // from_id no es necesario aquí para el viewer
					}
					break;
				case 'candidate':
					handleCandidate(data.candidate, data.from_id);
					break;
				
				// --- Casos para la lógica de tu juego (puedes añadir los que necesites) ---
				case 'evento_juego':
					// ... tu lógica para mostrar eventos ...
					break;
			}
		} catch (e) {
			// Esto es para mensajes que no son JSON, como los que envías desde tus endpoints HTTP
			console.log("Mensaje de texto plano recibido:", event.data);
		}
	};

		ws.onclose = (event) => {
			console.log("Conexión cerrada.", event.code, event.reason);
			clearInterval(heartbeatInterval);
			ws = null; // ¡Importante! Limpiamos la variable para permitir un nuevo intento

			// No reconectamos automáticamente, solo informamos al usuario.
			loginContainer.style.display = 'block';
			mainContainer.style.display = 'none';
			alert("Se ha perdido la conexión con el servidor. Por favor, intenta ingresar de nuevo.");
		};

		ws.onerror = (error) => {
			console.error("Error en WebSocket:", error);
			// onclose se llamará después de un error.
		};
	}

    // --- Lógica WebRTC ---

    // El espectador inicia la conexión
	/*
    function startViewing() {
        console.log("Iniciando conexión WebRTC como espectador...");
        peerConnection = new RTCPeerConnection(configuration);

        peerConnection.ontrack = (event) => {
            console.log("Track de video/audio remoto recibido.");
            liveStreamVideo.srcObject = event.streams[0];
            showStream();
        };

        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                ws.send(JSON.stringify({ 
                    type: 'candidate', 
                    candidate: event.candidate,
                    target_id: "streamer" // El servidor sabrá a quién enviarlo
                }));
            }
        };

        // El espectador añade transceptores para recibir video y audio
        peerConnection.addTransceiver('video', {'direction': 'recvonly'});
        peerConnection.addTransceiver('audio', {'direction': 'recvonly'});

        peerConnection.createOffer()
            .then(offer => peerConnection.setLocalDescription(offer))
            .then(() => {
                ws.send(JSON.stringify({ type: 'offer', offer: peerConnection.localDescription }));
            });
    }
    */
	
	// En index4.html

	function startViewing() {
		console.log("Iniciando conexión WebRTC como espectador...");
		
		// =================================================================
		// PASO 1: CREAR LA CONEXIÓN (¡ESTA LÍNEA ES FUNDAMENTAL!)
		// Aquí es donde se crea el objeto PeerConnection usando tu
		// configuración de servidores STUN y TURN.
		peerConnection = new RTCPeerConnection(configuration);
		// =================================================================


		// =================================================================
		// PASO 2: DEFINIR QUÉ HACER CUANDO LLEGUEN LOS DATOS
		// Este es el bloque que modificamos para forzar el play.
		peerConnection.ontrack = (event) => {
			console.log("Track de video/audio remoto recibido.");
			if (liveStreamVideo.srcObject !== event.streams[0]) {
				liveStreamVideo.srcObject = event.streams[0];
				console.log("Asignando nuevo stream al elemento de video.");
			}

			// Forzar la reproducción por si el autoplay falla
			const playPromise = liveStreamVideo.play();
			if (playPromise !== undefined) {
				playPromise.catch(error => {
					console.error("La reproducción automática fue bloqueada:", error);
					// Si falla, mostramos un mensaje para que el usuario haga clic
					showPlaceholder("La transmisión está lista. Haz clic en el video para reproducir.");
					// Añadimos un listener de clic para iniciar la reproducción manualmente
					liveStreamVideo.onclick = () => {
						liveStreamVideo.play();
						showStream();
						liveStreamVideo.onclick = null; // Quitar el evento para no interferir después
					};
				});
			}
			
			showStream();
		};
		// =================================================================


		// =================================================================
		// PASO 3: DEFINIR QUÉ HACER CON LOS CANDIDATOS ICE
		// Esto es para enviar nuestra información de red al otro par.
		peerConnection.onicecandidate = (event) => {
			if (event.candidate) {
				ws.send(JSON.stringify({ 
					type: 'candidate', 
					candidate: event.candidate,
					target_id: "streamer" // El servidor sabrá que es para el streamer
				}));
			}
		};
		// =================================================================


		// =================================================================
		// PASO 4: CONFIGURAR QUÉ QUEREMOS RECIBIR
		// Le decimos a la conexión que estamos esperando recibir video y audio.
		peerConnection.addTransceiver('video', {'direction': 'recvonly'});
		peerConnection.addTransceiver('audio', {'direction': 'recvonly'});
		// =================================================================


		// =================================================================
		// PASO 5: INICIAR LA NEGOCIACIÓN
		// Creamos y enviamos la "oferta" para empezar la conexión.
		peerConnection.createOffer()
			.then(offer => peerConnection.setLocalDescription(offer))
			.then(() => {
				ws.send(JSON.stringify({ type: 'offer', offer: peerConnection.localDescription }));
			})
			.catch(error => console.error("Error al crear la oferta:", error));
		// =================================================================
	}

    // El streamer maneja una oferta de un espectador
    async function handleOffer(offer, viewerId) {
        console.log(`Manejando oferta de ${viewerId}`);
        const pc = new RTCPeerConnection(configuration);
        peerConnections[viewerId] = pc;

        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        pc.onicecandidate = event => {
            if (event.candidate) {
                ws.send(JSON.stringify({ 
                    type: 'candidate', 
                    candidate: event.candidate,
                    target_id: viewerId 
                }));
            }
        };

        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        ws.send(JSON.stringify({ 
            type: 'answer', 
            answer: answer,
            target_id: viewerId 
        }));
    }

    // El espectador maneja la respuesta del streamer
    async function handleAnswer(answer) {
        if (peerConnection) {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        }
    }

    // Ambos manejan candidatos del otro
    async function handleCandidate(candidate, fromId) {
		// Para el streamer, pc será peerConnections[fromId]
		// Para el viewer, pc será la única 'peerConnection' que tiene
		const pc = (userRole === 'streamer') ? peerConnections[fromId] : peerConnection;
		if (pc) {
			try {
				await pc.addIceCandidate(new RTCIceCandidate(candidate));
			} catch (e) {
				console.error("Error añadiendo candidato ICE:", e);
			}
		}
	}
</script>
</body>
</html>