<!-- index4.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Ruleta Americana - WebRTC P2P</title>
    <!-- Tu CSS de index3.html va aquí. No necesita cambios. -->
    <style>
        body { font-family: sans-serif; padding: 20px; }
        #main-container, #capture-controls { display: none; }
        #login-container { text-align: center; margin-top: 50px; }
        .video-container { width: 100%; max-width: 600px; background-color: #000; border: 1px solid #ccc; position: relative; }
        #live-stream { width: 100%; display: block; }
        .video-placeholder { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #888; font-size: 1.5em; text-align: center; }
    </style>
</head>
<body>
    <!-- Tu HTML de index3.html va aquí, con un cambio clave: -->
    <div id="login-container">
        <h1>Bienvenido a la Ruleta Americana</h1>
        <p>Por favor, ingresa tu nombre para continuar.</p>
        <form id="login-form"><input type="text" id="name-input" placeholder="Tu nombre" required><button type="submit">Ingresar</button></form>
    </div>
    <div id="main-container">
        <h1>Ruleta Americana (Stream en Vivo - WebRTC)</h1>
        <div class="video-container">
            <!-- CAMBIO: Usamos un <video> para WebRTC, no una <img> -->
            <video id="live-stream" autoplay playsinline></video>
            <div id="streamPlaceholder" class="video-placeholder">Esperando transmisión...</div>
        </div>
        <div id="capture-controls">
            <button id="startButton">INICIAR TRANSMISIÓN</button>
        </div>
        <!-- El resto de tu HTML para apuestas, etc. no cambia -->
    </div>

<script>
    // --- Referencias al DOM ---
    const loginContainer = document.getElementById('login-container');
    const mainContainer = document.getElementById('main-container');
    const loginForm = document.getElementById('login-form');
    const nameInput = document.getElementById('name-input');
    const startButton = document.getElementById('startButton');
    const captureControls = document.getElementById('capture-controls');
    const liveStreamVideo = document.getElementById('live-stream');
    const streamPlaceholder = document.getElementById('streamPlaceholder');
    
    // --- Estado Global y Configuración ---
    let ws;
    let userRole = "viewer";
    let isStreaming = false;
    let localStream; // Para el streamer
    let peerConnections = {}; // Streamer: guarda una conexión por cada espectador
    let peerConnection;     // Espectador: solo tiene una conexión con el streamer

    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            {
              urls: 'turn:relay1.expressturn.com:3480',
              username: '000000002067441357',      // <-- ¡REEMPLAZA ESTO!
              credential: 'ZWtqCZGCwebs2UeE8c8ryeqBHN8=' // <-- ¡REEMPLAZA ESTO!
            }
        ]
    };
    
    // --- Lógica de la Aplicación ---
    loginForm.onsubmit = (event) => {
        event.preventDefault();
        connectWebSocket();
    };

    startButton.onclick = async () => {
        if (userRole === 'streamer' && !isStreaming) {
            try {
                localStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                isStreaming = true;
                startButton.disabled = true;
                startButton.textContent = "TRANSMITIENDO...";
                liveStreamVideo.srcObject = localStream; // El streamer ve su propio stream
                liveStreamVideo.muted = true;
                showStream();
                ws.send(JSON.stringify({ type: 'start_stream' }));

                localStream.getVideoTracks()[0].onended = () => {
                    ws.send(JSON.stringify({ type: 'stream_ended' }));
                };
            } catch (err) { console.error("Error al capturar pantalla:", err); }
        }
    };
    
    // --- Funciones de UI ---
    function showStream() {
        liveStreamVideo.style.visibility = 'visible';
        streamPlaceholder.style.display = 'none';
    }
    function showPlaceholder(message) {
        liveStreamVideo.style.visibility = 'hidden';
        streamPlaceholder.textContent = message;
        streamPlaceholder.style.display = 'block';
    }

    // --- Lógica de WebSocket ---
	
	function connectWebSocket() {
		const username = nameInput.value.trim();
		if (!username) {
			alert("Por favor, ingresa un nombre.");
			return;
		}

		const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
		const wsHost = window.location.host;
		ws = new WebSocket(`${wsProtocol}//${wsHost}/ws/users`);

		let heartbeatInterval; // Para nuestro latido

		ws.onopen = () => {
			console.log("Conectado al servidor.");
			ws.send(JSON.stringify({ type: "login", name: username }));

			// Iniciar el heartbeat para mantener la conexión viva
			heartbeatInterval = setInterval(() => {
				if (ws.readyState === WebSocket.OPEN) {
					ws.send(JSON.stringify({ type: 'ping' }));
				}
			}, 25000); // Cada 25 segundos
		};

		ws.onmessage = (event) => {
			try {
				const data = JSON.parse(event.data);
				
				// Ignorar las respuestas del heartbeat
				if (data.type === 'pong') {
					return;
				}

				console.log("Mensaje recibido:", data);
				
				// Tu switch case existente para manejar los mensajes de la aplicación
				switch (data.type) {
					case 'login_success':
						userRole = data.role;
						loginContainer.style.display = 'none';
						mainContainer.style.display = 'block';
						if (userRole === 'streamer') captureControls.style.display = 'block';
						break;

					case 'stream_started':
						showStream();
						if (userRole === 'viewer') startViewing();
						break;
					
					case 'stream_ended':
						isStreaming = false;
						showPlaceholder("La transmisión ha finalizado.");
						if (userRole === 'streamer') {
							startButton.disabled = false;
							startButton.textContent = "INICIAR TRANSMISIÓN";
							if (localStream) localStream.getTracks().forEach(track => track.stop());
							localStream = null;
							Object.values(peerConnections).forEach(pc => pc.close());
							peerConnections = {};
						} else {
							if (peerConnection) peerConnection.close();
							peerConnection = null;
							liveStreamVideo.srcObject = null; // Limpiar el video del espectador
						}
						break;

					case 'offer':
						if (userRole === 'streamer') handleOffer(data.offer, data.from_id);
						break;
					case 'answer':
						if (userRole === 'viewer') handleAnswer(data.answer, data.from_id);
						break;
					case 'candidate':
						handleCandidate(data.candidate, data.from_id);
						break;
				}
			} catch (e) {
				console.error("Error al procesar el mensaje o mensaje no es JSON:", event.data, e);
			}
		};

		ws.onclose = () => {
			console.log("Conexión cerrada. Intentando reconectar en 3 segundos...");
			clearInterval(heartbeatInterval); // Detener el heartbeat
			// Limpiar el estado para forzar un re-login
			loginContainer.style.display = 'block';
			mainContainer.style.display = 'none';
			// Intentar reconectar después de un breve retraso
			setTimeout(connectWebSocket, 3000); 
		};

		ws.onerror = (error) => {
			console.error("Error en WebSocket:", error);
			// El evento onclose se disparará automáticamente después de un error,
			// así que la lógica de reconexión se activará.
		};
	}

    // --- Lógica WebRTC ---

    // El espectador inicia la conexión
	/*
    function startViewing() {
        console.log("Iniciando conexión WebRTC como espectador...");
        peerConnection = new RTCPeerConnection(configuration);

        peerConnection.ontrack = (event) => {
            console.log("Track de video/audio remoto recibido.");
            liveStreamVideo.srcObject = event.streams[0];
            showStream();
        };

        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                ws.send(JSON.stringify({ 
                    type: 'candidate', 
                    candidate: event.candidate,
                    target_id: "streamer" // El servidor sabrá a quién enviarlo
                }));
            }
        };

        // El espectador añade transceptores para recibir video y audio
        peerConnection.addTransceiver('video', {'direction': 'recvonly'});
        peerConnection.addTransceiver('audio', {'direction': 'recvonly'});

        peerConnection.createOffer()
            .then(offer => peerConnection.setLocalDescription(offer))
            .then(() => {
                ws.send(JSON.stringify({ type: 'offer', offer: peerConnection.localDescription }));
            });
    }
    */
	
	// En index4.html

	function startViewing() {
		console.log("Iniciando conexión WebRTC como espectador...");
		
		// =================================================================
		// PASO 1: CREAR LA CONEXIÓN (¡ESTA LÍNEA ES FUNDAMENTAL!)
		// Aquí es donde se crea el objeto PeerConnection usando tu
		// configuración de servidores STUN y TURN.
		peerConnection = new RTCPeerConnection(configuration);
		// =================================================================


		// =================================================================
		// PASO 2: DEFINIR QUÉ HACER CUANDO LLEGUEN LOS DATOS
		// Este es el bloque que modificamos para forzar el play.
		peerConnection.ontrack = (event) => {
			console.log("Track de video/audio remoto recibido.");
			if (liveStreamVideo.srcObject !== event.streams[0]) {
				liveStreamVideo.srcObject = event.streams[0];
				console.log("Asignando nuevo stream al elemento de video.");
			}

			// Forzar la reproducción por si el autoplay falla
			const playPromise = liveStreamVideo.play();
			if (playPromise !== undefined) {
				playPromise.catch(error => {
					console.error("La reproducción automática fue bloqueada:", error);
					// Si falla, mostramos un mensaje para que el usuario haga clic
					showPlaceholder("La transmisión está lista. Haz clic en el video para reproducir.");
					// Añadimos un listener de clic para iniciar la reproducción manualmente
					liveStreamVideo.onclick = () => {
						liveStreamVideo.play();
						showStream();
						liveStreamVideo.onclick = null; // Quitar el evento para no interferir después
					};
				});
			}
			
			showStream();
		};
		// =================================================================


		// =================================================================
		// PASO 3: DEFINIR QUÉ HACER CON LOS CANDIDATOS ICE
		// Esto es para enviar nuestra información de red al otro par.
		peerConnection.onicecandidate = (event) => {
			if (event.candidate) {
				ws.send(JSON.stringify({ 
					type: 'candidate', 
					candidate: event.candidate,
					target_id: "streamer" // El servidor sabrá que es para el streamer
				}));
			}
		};
		// =================================================================


		// =================================================================
		// PASO 4: CONFIGURAR QUÉ QUEREMOS RECIBIR
		// Le decimos a la conexión que estamos esperando recibir video y audio.
		peerConnection.addTransceiver('video', {'direction': 'recvonly'});
		peerConnection.addTransceiver('audio', {'direction': 'recvonly'});
		// =================================================================


		// =================================================================
		// PASO 5: INICIAR LA NEGOCIACIÓN
		// Creamos y enviamos la "oferta" para empezar la conexión.
		peerConnection.createOffer()
			.then(offer => peerConnection.setLocalDescription(offer))
			.then(() => {
				ws.send(JSON.stringify({ type: 'offer', offer: peerConnection.localDescription }));
			})
			.catch(error => console.error("Error al crear la oferta:", error));
		// =================================================================
	}

    // El streamer maneja una oferta de un espectador
    async function handleOffer(offer, viewerId) {
        console.log(`Manejando oferta de ${viewerId}`);
        const pc = new RTCPeerConnection(configuration);
        peerConnections[viewerId] = pc;

        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        pc.onicecandidate = event => {
            if (event.candidate) {
                ws.send(JSON.stringify({ 
                    type: 'candidate', 
                    candidate: event.candidate,
                    target_id: viewerId 
                }));
            }
        };

        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        ws.send(JSON.stringify({ 
            type: 'answer', 
            answer: answer,
            target_id: viewerId 
        }));
    }

    // El espectador maneja la respuesta del streamer
    async function handleAnswer(answer) {
        if (peerConnection) {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        }
    }

    // Ambos manejan candidatos del otro
    async function handleCandidate(candidate, fromId) {
        const pc = userRole === 'streamer' ? peerConnections[fromId] : peerConnection;
        if (pc) {
            try {
                await pc.addIceCandidate(new RTCIceCandidate(candidate));
            } catch (e) {
                console.error("Error añadiendo candidato ICE:", e);
            }
        }
    }
</script>
</body>
</html>