<!-- index4.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Ruleta Americana - WebRTC P2P</title>
    <!-- Tu CSS de index3.html va aquí. No necesita cambios. -->
    <style>
        body { font-family: sans-serif; padding: 20px; }
        #main-container, #capture-controls { display: none; }
        #login-container { text-align: center; margin-top: 50px; }
        .video-container { width: 100%; max-width: 600px; background-color: #000; border: 1px solid #ccc; position: relative; }
        #live-stream { width: 100%; display: block; }
        .video-placeholder { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #888; font-size: 1.5em; text-align: center; }
		#welcome-container {
			display: none; /* Oculto por defecto */
			text-align: center;
			margin-top: 50px;
			padding: 20px;
			border: 1px solid #ccc;
			border-radius: 8px;
			max-width: 600px;
			margin-left: auto;
			margin-right: auto;
		}

		#enter-game-button {
			padding: 15px 30px;
			font-size: 18px;
			font-weight: bold;
			color: white;
			background-color: #007bff;
			border: none;
			border-radius: 5px;
			cursor: pointer;
			margin-top: 20px;
		}
		#enter-game-button:hover {
			background-color: #0056b3;
		}
    </style>
</head>
<body>
    <!-- Tu HTML de index3.html va aquí, con un cambio clave: -->
    <div id="login-container">
        <h1>Bienvenido a la Ruleta Americana</h1>
        <p>Por favor, ingresa tu nombre para continuar.</p>
        <form id="login-form"><input type="text" id="name-input" placeholder="Tu nombre" required><button type="submit">Ingresar</button></form>
    </div>
	<div id="welcome-container">
        <h1 id="welcome-message"></h1>
        <p>¡Todo listo para empezar!</p>
        <!-- Aquí podrías poner tu video tutorial si quisieras -->
        <!-- <video src="tutorial.mp4" controls></video> -->
        <button id="enter-game-button">ENTRAR AL JUEGO</button>
    </div>
    <div id="main-container">
        <h1>Ruleta Americana (Stream en Vivo - WebRTC)</h1>
        <div class="video-container">
            <!-- CAMBIO: Usamos un <video> para WebRTC, no una <img> -->
			<video id="live-stream" autoplay muted playsinline></video>
            <div id="streamPlaceholder" class="video-placeholder">Esperando transmisión...</div>
        </div>
        <div id="capture-controls">
            <button id="startButton">INICIAR TRANSMISIÓN</button>
        </div>
        <!-- El resto de tu HTML para apuestas, etc. no cambia -->
    </div>

<script>
    // --- Referencias al DOM ---
    const loginContainer = document.getElementById('login-container');
    const mainContainer = document.getElementById('main-container');
    const loginForm = document.getElementById('login-form');
    const nameInput = document.getElementById('name-input');
    const startButton = document.getElementById('startButton');
    const captureControls = document.getElementById('capture-controls');
    const liveStreamVideo = document.getElementById('live-stream');
    const streamPlaceholder = document.getElementById('streamPlaceholder');
    // Nuevas referencias para el flujo de bienvenida
    const welcomeContainer = document.getElementById('welcome-container');
    const welcomeMessage = document.getElementById('welcome-message');
    const enterGameButton = document.getElementById('enter-game-button');
    // Referencias a los elementos de tu juego (asegúrate de que los IDs coincidan en tu HTML)
    const nombreLogueadoElem = document.getElementById('nombre-logueado');

    // --- Estado Global y Configuración ---
    let ws = null;
    let userRole = "viewer";
    let isStreaming = false;
    let localStream; // Para el streamer
    let peerConnections = {}; // Streamer: guarda una conexión por cada espectador
    let peerConnection; // Espectador: solo tiene una conexión con el streamer
    let currentUsername = ''; // Para guardar el nombre del usuario
    
    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            {
              urls: 'turn:relay1.expressturn.com:3480',
              username: '000000002067441357',
              credential: 'ZWtqCZGCwebs2UeE8c8ryeqBHN8='
            }
        ]
    };
    
    // ===================================================================
    // --- INICIO DEL FLUJO DE LA APLICACIÓN ---
    // ===================================================================

    // 1. El usuario envía el formulario de login
    loginForm.onsubmit = (event) => {
        event.preventDefault();
        const username = nameInput.value.trim();
        if (username) {
            if (!ws || ws.readyState === WebSocket.CLOSED) {
                currentUsername = username; // Guardamos el nombre
                connectWebSocket(username);
            } else {
                console.log("Ya se está intentando una conexión.");
            }
        } else {
            alert("Por favor, ingresa un nombre.");
        }
    };

    // 2. El usuario (ya logueado) hace clic en el botón de "Entrar al Juego"
    enterGameButton.onclick = () => {
        // Este es el gesto de usuario que "calienta" el navegador
        console.log("Usuario ha entrado al juego. Mostrando contenedor principal.");
        welcomeContainer.style.display = 'none';
        mainContainer.style.display = 'block';

        if (userRole === 'streamer') {
            captureControls.style.display = 'block';
        }
        
        // Si el stream ya había empezado mientras estábamos en la pantalla de bienvenida,
        // iniciamos la conexión WebRTC ahora.
        if (userRole === 'viewer' && isStreaming) {
            console.log("Stream ya está activo. Iniciando visualización...");
            startViewing();
        }
    };

    // 3. El streamer hace clic en "Iniciar Transmisión"
    startButton.onclick = async () => {
        if (userRole === 'streamer' && !isStreaming) {
            try {
                localStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                isStreaming = true; // Actualizamos el estado primero
                startButton.disabled = true;
                startButton.textContent = "TRANSMITIENDO...";
                liveStreamVideo.srcObject = localStream;
                liveStreamVideo.muted = true;
                showStream();
                
                // Notificamos al servidor que el stream ha comenzado
                ws.send(JSON.stringify({ type: 'start_stream' }));

                // Listener para cuando el streamer detiene la compartición desde el navegador
                localStream.getVideoTracks()[0].onended = () => {
                    ws.send(JSON.stringify({ type: 'stream_ended' }));
                };
            } catch (err) { 
                console.error("Error al capturar pantalla (el usuario pudo haber cancelado):", err.name); 
            }
        }
    };

    // ===================================================================
    // --- LÓGICA DE WEBSOCKET ---
    // ===================================================================

    function connectWebSocket(username) {
        console.log("Intentando conectar WebSocket...");
        
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsHost = window.location.host;
        ws = new WebSocket(`${wsProtocol}//${wsHost}/ws/users`);

        let heartbeatInterval;

        ws.onopen = () => {
            console.log("Conectado al servidor. WebSocket está OPEN.");
            ws.send(JSON.stringify({ type: "login", name: username }));

            heartbeatInterval = setInterval(() => {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'ping' }));
                }
            }, 25000);
        };

        ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'pong') return; // Ignorar pongs
                
                console.log("Mensaje recibido:", data);

                switch (data.type) {
                    case 'login_success':
                        userRole = data.role;
                        // Mostramos la pantalla de bienvenida, no la del juego directamente
                        loginContainer.style.display = 'none';
                        welcomeContainer.style.display = 'block';
                        welcomeMessage.textContent = `¡Bienvenido, ${currentUsername}!`;
                        break;

                    case 'stream_started':
                        isStreaming = true;
                        // Solo actuamos si ya estamos en la pantalla del juego
                        if (mainContainer.style.display === 'block' && userRole === 'viewer') {
                            showStream();
                            startViewing();
                        }
                        break;
                    
                    case 'stream_ended':
                        isStreaming = false;
                        showPlaceholder("La transmisión ha finalizado.");
                        if (userRole === 'streamer') {
                            startButton.disabled = false;
                            startButton.textContent = "INICIAR TRANSMISIÓN";
                            if (localStream) localStream.getTracks().forEach(track => track.stop());
                            localStream = null;
                            Object.values(peerConnections).forEach(pc => pc.close());
                            peerConnections = {};
                        } else {
                            if (peerConnection) peerConnection.close();
                            peerConnection = null;
                            liveStreamVideo.srcObject = null;
                        }
                        break;

                    case 'offer':
                        if (userRole === 'streamer') handleOffer(data.offer, data.from_id);
                        break;
                    case 'answer':
                        if (userRole === 'viewer') handleAnswer(data.answer);
                        break;
                    case 'candidate':
                        handleCandidate(data.candidate, data.from_id);
                        break;
                }
            } catch (e) {
                console.log("Mensaje de texto plano recibido:", event.data);
            }
        };

        ws.onclose = (event) => {
            console.log("Conexión cerrada.", event.code, event.reason);
            clearInterval(heartbeatInterval);
            ws = null;
            // Ocultamos todos los contenedores y mostramos solo el de login
            loginContainer.style.display = 'block';
            mainContainer.style.display = 'none';
            welcomeContainer.style.display = 'none';
            alert("Se ha perdido la conexión con el servidor. Por favor, ingresa de nuevo.");
        };

        ws.onerror = (error) => {
            console.error("Error en WebSocket:", error);
        };
    }

///////////////////////////////////////////////////////////////////////////////
// ===================================================================
    // --- LÓGICA DE WEBRTC ---
    // ===================================================================
	
	function startViewing() {
		console.log("Iniciando conexión WebRTC como espectador...");
		
		// =================================================================
		// PASO 1: CREAR LA CONEXIÓN (¡ESTA LÍNEA ES FUNDAMENTAL!)
		// Aquí es donde se crea el objeto PeerConnection usando tu
		// configuración de servidores STUN y TURN.
		peerConnection = new RTCPeerConnection(configuration);
		// =================================================================


		// =================================================================
		// PASO 2: DEFINIR QUÉ HACER CUANDO LLEGUEN LOS DATOS
		// Este es el bloque que modificamos para forzar el play.
		peerConnection.ontrack = (event) => {
			console.log("-> EVENTO ONTRACK DISPARADO");

			const remoteStream = event.streams[0];
			if (liveStreamVideo.srcObject !== remoteStream) {
				console.log("Asignando nuevo stream al elemento de video.");
				liveStreamVideo.srcObject = remoteStream;
			}

			// El navegador requiere una interacción del usuario para reproducir video con sonido.
			// La mejor práctica es poner el video remoto en 'muted' y 'autoplay'.
			// El usuario puede desmutearlo si quiere.
			liveStreamVideo.muted = true;
			liveStreamVideo.playsInline = true; // Importante para móviles

			console.log("Intentando reproducir el video...");
			const playPromise = liveStreamVideo.play();

			if (playPromise !== undefined) {
				playPromise.then(() => {
					// El autoplay funcionó.
					console.log("¡La reproducción del video se inició con éxito!");
					showStream();
				}).catch(error => {
					// El autoplay fue bloqueado por el navegador.
					console.error("La reproducción automática fue bloqueada:", error);
					showPlaceholder("Transmisión lista. Haz clic aquí para reproducir.");

					// Añadimos un listener de un solo uso para que el usuario inicie la reproducción.
					const playOnClick = () => {
						console.log("Intentando reproducir por clic del usuario...");
						liveStreamVideo.play().then(() => {
							console.log("¡Reproducción iniciada por el usuario!");
							showStream();
							// Removemos este listener una vez que ha funcionado.
							liveStreamVideo.removeEventListener('click', playOnClick);
						}).catch(err => {
							console.error("La reproducción por clic también falló:", err);
						});
					};
					liveStreamVideo.addEventListener('click', playOnClick);
				});
			}
		};
		// =================================================================


		// =================================================================
		// PASO 3: DEFINIR QUÉ HACER CON LOS CANDIDATOS ICE
		// Esto es para enviar nuestra información de red al otro par.
		peerConnection.onicecandidate = (event) => {
			if (event.candidate) {
				ws.send(JSON.stringify({ 
					type: 'candidate', 
					candidate: event.candidate,
					target_id: "streamer" // El servidor sabrá que es para el streamer
				}));
			}
		};
		// =================================================================


		// =================================================================
		// PASO 4: CONFIGURAR QUÉ QUEREMOS RECIBIR
		// Le decimos a la conexión que estamos esperando recibir video y audio.
		peerConnection.addTransceiver('video', {'direction': 'recvonly'});
		peerConnection.addTransceiver('audio', {'direction': 'recvonly'});
		// =================================================================


		// =================================================================
		// PASO 5: INICIAR LA NEGOCIACIÓN
		// Creamos y enviamos la "oferta" para empezar la conexión.
		peerConnection.createOffer()
			.then(offer => peerConnection.setLocalDescription(offer))
			.then(() => {
				ws.send(JSON.stringify({ type: 'offer', offer: peerConnection.localDescription }));
			})
			.catch(error => console.error("Error al crear la oferta:", error));
		// =================================================================
	}

    // El streamer maneja una oferta de un espectador
    async function handleOffer(offer, viewerId) {
        console.log(`Manejando oferta de ${viewerId}`);
        const pc = new RTCPeerConnection(configuration);
        peerConnections[viewerId] = pc;

        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        pc.onicecandidate = event => {
            if (event.candidate) {
                ws.send(JSON.stringify({ 
                    type: 'candidate', 
                    candidate: event.candidate,
                    target_id: viewerId 
                }));
            }
        };

        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        ws.send(JSON.stringify({ 
            type: 'answer', 
            answer: answer,
            target_id: viewerId 
        }));
    }
	
	    // El espectador maneja la respuesta del streamer
    async function handleAnswer(answer) {
        if (peerConnection) {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        }
    }
	
	// Ambos manejan candidatos del otro
    async function handleCandidate(candidate, fromId) {
		// Para el streamer, pc será peerConnections[fromId]
		// Para el viewer, pc será la única 'peerConnection' que tiene
		const pc = (userRole === 'streamer') ? peerConnections[fromId] : peerConnection;
		if (pc) {
			try {
				await pc.addIceCandidate(new RTCIceCandidate(candidate));
			} catch (e) {
				console.error("Error añadiendo candidato ICE:", e);
			}
		}
	}
	
	// --- Funciones de UI ---
    function showStream() {
        liveStreamVideo.style.visibility = 'visible';
        streamPlaceholder.style.display = 'none';
    }
	
    function showPlaceholder(message) {
        liveStreamVideo.style.visibility = 'hidden';
        streamPlaceholder.textContent = message;
        streamPlaceholder.style.display = 'block';
    }
	




    
</script>
</body>
</html>