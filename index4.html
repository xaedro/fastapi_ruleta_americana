<!-- index4.html 
<!DOCTYPE html>
<html>
<head>
    <title>Ruleta Americana - WebRTC P2P</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        #main-container, #capture-controls { display: none; }
        #login-container { text-align: center; margin-top: 50px; }
        .video-container { width: 100%; max-width: 600px; background-color: #000; border: 1px solid #ccc; position: relative; }
        #live-stream { width: 100%; display: block; }
        .video-placeholder { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #888; font-size: 1.5em; text-align: center; }
		#welcome-container {
			display: none; /* Oculto por defecto */
			text-align: center;
			margin-top: 50px;
			padding: 20px;
			border: 1px solid #ccc;
			border-radius: 8px;
			max-width: 600px;
			margin-left: auto;
			margin-right: auto;
		}

		#enter-game-button {
			padding: 15px 30px;
			font-size: 18px;
			font-weight: bold;
			color: white;
			background-color: #007bff;
			border: none;
			border-radius: 5px;
			cursor: pointer;
			margin-top: 20px;
		}
		#enter-game-button:hover {
			background-color: #0056b3;
		}
		#tutorial-video {
			width: 50%;
			height: auto; /* Se ajusta automáticamente para mantener la proporción */
		}
    </style>
</head>
<body>
    <div id="login-container">
        <h1>Bienvenido a la Ruleta Americana</h1>
        <p>Por favor, ingresa tu nombre para continuar.</p>
        <form id="login-form"><input type="text" id="name-input" placeholder="Tu nombre" required><button type="submit">Ingresar</button></form>
    </div>
	<div id="welcome-container">
        <h1 id="welcome-message"></h1>
        <p>¡Todo listo para empezar!</p>
        <video id="tutorial-video" src="/static/color_wheel.mp4" controls></video>
        <button id="enter-game-button">ENTRAR AL JUEGO</button>
    </div>
    <div id="main-container">
        <h1>Ruleta Americana (Stream en Vivo - WebRTC)</h1>
        <div class="video-container">
			<video id="live-stream" autoplay muted playsinline></video>
            <div id="streamPlaceholder" class="video-placeholder">Esperando transmisión...</div>
        </div>
        <div id="capture-controls">
            <button id="startButton">INICIAR TRANSMISIÓN</button>
        </div>
    </div>

<script>
    // --- Referencias al DOM ---
    const loginContainer = document.getElementById('login-container');
    const mainContainer = document.getElementById('main-container');
    const loginForm = document.getElementById('login-form');
    const nameInput = document.getElementById('name-input');
    const startButton = document.getElementById('startButton');
    const captureControls = document.getElementById('capture-controls');
    const liveStreamVideo = document.getElementById('live-stream');
    const streamPlaceholder = document.getElementById('streamPlaceholder');
    // Nuevas referencias para el flujo de bienvenida
    const welcomeContainer = document.getElementById('welcome-container');
    const welcomeMessage = document.getElementById('welcome-message');
    const enterGameButton = document.getElementById('enter-game-button');
    // Referencias a los elementos de tu juego (asegúrate de que los IDs coincidan en tu HTML)
    const nombreLogueadoElem = document.getElementById('nombre-logueado');

    // --- Estado Global y Configuración ---
    let ws = null;
    let userRole = "viewer";
    let isStreaming = false;
    let localStream; // Para el streamer
    let peerConnections = {}; // Streamer: guarda una conexión por cada espectador
    let peerConnection; // Espectador: solo tiene una conexión con el streamer
    let currentUsername = ''; // Para guardar el nombre del usuario
    
    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            {
              urls: 'turn:relay1.expressturn.com:3480',
              username: '000000002067441357',
              credential: 'ZWtqCZGCwebs2UeE8c8ryeqBHN8='
            }
        ]
    };
    
    // ===================================================================
    // --- INICIO DEL FLUJO DE LA APLICACIÓN ---
    // ===================================================================

    // 1. El usuario envía el formulario de login
    loginForm.onsubmit = (event) => {
        event.preventDefault();
        const username = nameInput.value.trim();
        if (username) {
            if (!ws || ws.readyState === WebSocket.CLOSED) {
                currentUsername = username; // Guardamos el nombre
                connectWebSocket(username);
            } else {
                console.log("Ya se está intentando una conexión.");
            }
        } else {
            alert("Por favor, ingresa un nombre.");
        }
    };

    // 2. El usuario (ya logueado) hace clic en el botón de "Entrar al Juego"
    enterGameButton.onclick = () => {
        // Este es el gesto de usuario que "calienta" el navegador
        console.log("Usuario ha entrado al juego. Mostrando contenedor principal.");
        welcomeContainer.style.display = 'none';
        mainContainer.style.display = 'block';

        if (userRole === 'streamer') {
            captureControls.style.display = 'block';
        }
        
        // Si el stream ya había empezado mientras estábamos en la pantalla de bienvenida,
        // iniciamos la conexión WebRTC ahora.
        if (userRole === 'viewer' && isStreaming) {
            console.log("Stream ya está activo. Iniciando visualización...");
            startViewing();
        }
    };

    // 3. El streamer hace clic en "Iniciar Transmisión"
	/*
    startButton.onclick = async () => {
        if (userRole === 'streamer' && !isStreaming) {
            try {
                localStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                isStreaming = true; // Actualizamos el estado primero
                startButton.disabled = true;
                startButton.textContent = "TRANSMITIENDO...";
                liveStreamVideo.srcObject = localStream;
                liveStreamVideo.muted = true;
                showStream();
                
                // Notificamos al servidor que el stream ha comenzado
                ws.send(JSON.stringify({ type: 'start_stream' }));

                // Listener para cuando el streamer detiene la compartición desde el navegador
                localStream.getVideoTracks()[0].onended = () => {
                    ws.send(JSON.stringify({ type: 'stream_ended' }));
                };
            } catch (err) { 
                console.error("Error al capturar pantalla (el usuario pudo haber cancelado):", err.name); 
            }
        }
    };
	*/
	startButton.onclick = async () => {
		if (userRole === 'streamer' && !isStreaming) {
			try {
				localStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
				isStreaming = true; // Actualizamos el estado primero
				startButton.disabled = true;
				startButton.textContent = "TRANSMITIENDO...";
				liveStreamVideo.srcObject = localStream;
				liveStreamVideo.muted = true;
				showStream();

				// Agregar las pistas del stream local al RTCPeerConnection
				localStream.getTracks().forEach((track) => {
					peerConnection.addTrack(track, localStream);
					console.log(`Pista añadida: ${track.kind} (id: ${track.id})`);
				});

				// Notificamos al servidor que el stream ha comenzado
				ws.send(JSON.stringify({ type: 'start_stream' }));

				// Listener para cuando el streamer detiene la compartición desde el navegador
				localStream.getVideoTracks()[0].onended = () => {
					ws.send(JSON.stringify({ type: 'stream_ended' }));
					// Opcional: Cerrar la conexión o limpiar el estado
					isStreaming = false;
					startButton.disabled = false;
					startButton.textContent = "Iniciar Stream";
				};
			} catch (err) {
				console.error("Error al capturar pantalla (el usuario pudo haber cancelado):", err.name);
			}
		} else {
			alert("Ya hau un stream ejecutándose");
		}
	};
	
    // ===================================================================
    // --- LÓGICA DE WEBSOCKET ---
    // ===================================================================

    function connectWebSocket(username) {
        console.log("Intentando conectar WebSocket...");
        
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsHost = window.location.host;
        ws = new WebSocket(`${wsProtocol}//${wsHost}/ws/users`);

        let heartbeatInterval;

        ws.onopen = () => {
            console.log("Conectado al servidor. WebSocket está OPEN.");
            ws.send(JSON.stringify({ type: "login", name: username }));

            heartbeatInterval = setInterval(() => {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'ping' }));
                }
            }, 25000);
        };

        ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'pong') return; // Ignorar pongs
                
                console.log("Mensaje recibido:", data);

                switch (data.type) {
                    case 'login_success':
                        userRole = data.role;
                        // Mostramos la pantalla de bienvenida, no la del juego directamente
                        loginContainer.style.display = 'none';
                        welcomeContainer.style.display = 'block';
                        welcomeMessage.textContent = `¡Bienvenido, ${currentUsername}!`;
                        break;

                    case 'stream_started':
                        isStreaming = true;
                        // Solo actuamos si ya estamos en la pantalla del juego
                        if (mainContainer.style.display === 'block' && userRole === 'viewer') {
                            showStream();
                            startViewing();
                        }
                        break;
                    
                    case 'stream_ended':
                        isStreaming = false;
                        showPlaceholder("La transmisión ha finalizado.");
                        if (userRole === 'streamer') {
                            startButton.disabled = false;
                            startButton.textContent = "INICIAR TRANSMISIÓN";
                            if (localStream) localStream.getTracks().forEach(track => track.stop());
                            localStream = null;
                            Object.values(peerConnections).forEach(pc => pc.close());
                            peerConnections = {};
                        } else {
                            if (peerConnection) peerConnection.close();
                            peerConnection = null;
                            liveStreamVideo.srcObject = null;
                        }
                        break;

                    case 'offer':
                        if (userRole === 'streamer') handleOffer(data.offer, data.from_id);
                        break;
                    case 'answer':
                        if (userRole === 'viewer') handleAnswer(data.answer);
                        break;
                    case 'candidate':
                        handleCandidate(data.candidate, data.from_id);
                        break;
                }
            } catch (e) {
                console.log("Mensaje de texto plano recibido:", event.data);
            }
        };

        ws.onclose = (event) => {
            console.log("Conexión cerrada.", event.code, event.reason);
            clearInterval(heartbeatInterval);
            ws = null;
            // Ocultamos todos los contenedores y mostramos solo el de login
            loginContainer.style.display = 'block';
            mainContainer.style.display = 'none';
            welcomeContainer.style.display = 'none';
            alert("Se ha perdido la conexión con el servidor. Por favor, ingresa de nuevo.");
        };

        ws.onerror = (error) => {
            console.error("Error en WebSocket:", error);
        };
    }

///////////////////////////////////////////////////////////////////////////////
// ===================================================================
    // --- LÓGICA DE WEBRTC ---
    // ===================================================================
	
	function startViewing() {
		console.log("Iniciando conexión WebRTC como espectador...");
		
		// =================================================================
		// PASO 1: CREAR LA CONEXIÓN (¡ESTA LÍNEA ES FUNDAMENTAL!)
		// Aquí es donde se crea el objeto PeerConnection usando tu
		// configuración de servidores STUN y TURN.
		peerConnection = new RTCPeerConnection(configuration);
		// =================================================================


		// =================================================================
		// PASO 2: DEFINIR QUÉ HACER CUANDO LLEGUEN LOS DATOS
		// Este es el bloque que modificamos para forzar el play.
		peerConnection.ontrack = (event) => {
			console.log("-> EVENTO ONTRACK DISPARADO");

			const remoteStream = event.streams[0];
			console.log("Pistas de video:", remoteStream.getVideoTracks());
			console.log("Pistas de audio:", remoteStream.getAudioTracks());

			if (liveStreamVideo.srcObject !== remoteStream) {
				console.log("Asignando nuevo stream al elemento de video.");
				liveStreamVideo.srcObject = remoteStream;
			}

			// El navegador requiere una interacción del usuario para reproducir video con sonido.
			// La mejor práctica es poner el video remoto en 'muted' y 'autoplay'.
			// El usuario puede desmutearlo si quiere.
			liveStreamVideo.muted = true;
			liveStreamVideo.playsInline = true; // Importante para móviles

			console.log("Intentando reproducir el video...");
			const playPromise = liveStreamVideo.play();

			if (playPromise !== undefined) {
				playPromise.then(() => {
					// El autoplay funcionó.
					console.log("¡La reproducción del video se inició con éxito!");
					showStream();
				}).catch(error => {
					// El autoplay fue bloqueado por el navegador.
					console.error("La reproducción automática fue bloqueada:", error);
					showPlaceholder("Transmisión lista. Haz clic aquí para reproducir.");

					// Añadimos un listener de un solo uso para que el usuario inicie la reproducción.
					const playOnClick = () => {
						console.log("Intentando reproducir por clic del usuario...");
						liveStreamVideo.play().then(() => {
							console.log("¡Reproducción iniciada por el usuario!");
							showStream();
							// Removemos este listener una vez que ha funcionado.
							liveStreamVideo.removeEventListener('click', playOnClick);
						}).catch(err => {
							console.error("La reproducción por clic también falló:", err);
						});
					};
					liveStreamVideo.addEventListener('click', playOnClick);
				});
			}
		};
		// =================================================================


		// =================================================================
		// PASO 3: DEFINIR QUÉ HACER CON LOS CANDIDATOS ICE
		// Esto es para enviar nuestra información de red al otro par.
		peerConnection.onicecandidate = (event) => {
			if (event.candidate) {
				console.log('ICE Candidate:', event.candidate);
				ws.send(JSON.stringify({ 
					type: 'candidate', 
					candidate: event.candidate,
					target_id: "streamer" // El servidor sabrá que es para el streamer
				}));
			}
		};
		// =================================================================


		// =================================================================
		// PASO 4: CONFIGURAR QUÉ QUEREMOS RECIBIR
		// Le decimos a la conexión que estamos esperando recibir video y audio.
		peerConnection.addTransceiver('video', {'direction': 'recvonly'});
		peerConnection.addTransceiver('audio', {'direction': 'recvonly'});
		// =================================================================


		// =================================================================
		// PASO 5: INICIAR LA NEGOCIACIÓN
		// Creamos y enviamos la "oferta" para empezar la conexión.
		peerConnection.createOffer()
			.then(offer => peerConnection.setLocalDescription(offer))
			.then(() => {
				ws.send(JSON.stringify({ type: 'offer', offer: peerConnection.localDescription }));
			})
			.catch(error => console.error("Error al crear la oferta:", error));
		// =================================================================
	}

    // El streamer maneja una oferta de un espectador
    async function handleOffer(offer, viewerId) {
        console.log(`Manejando oferta de ${viewerId}`);
        const pc = new RTCPeerConnection(configuration);
        peerConnections[viewerId] = pc;

        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        pc.onicecandidate = event => {
            if (event.candidate) {
                ws.send(JSON.stringify({ 
                    type: 'candidate', 
                    candidate: event.candidate,
                    target_id: viewerId 
                }));
            }
        };

        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        ws.send(JSON.stringify({ 
            type: 'answer', 
            answer: answer,
            target_id: viewerId 
        }));
    }
	
	// El espectador maneja la respuesta del streamer
    async function handleAnswer(answer) {
        if (peerConnection) {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        }
    }
	
	// Ambos manejan candidatos del otro
    async function handleCandidate(candidate, fromId) {
		// Para el streamer, pc será peerConnections[fromId]
		// Para el viewer, pc será la única 'peerConnection' que tiene
		const pc = (userRole === 'streamer') ? peerConnections[fromId] : peerConnection;
		if (pc) {
			try {
				await pc.addIceCandidate(new RTCIceCandidate(candidate));
			} catch (e) {
				console.error("Error añadiendo candidato ICE:", e);
			}
		}
	}
	
	// --- Funciones de UI ---
    function showStream() {
        liveStreamVideo.style.visibility = 'visible';
        streamPlaceholder.style.display = 'none';
    }
	
    function showPlaceholder(message) {
        liveStreamVideo.style.visibility = 'hidden';
        streamPlaceholder.textContent = message;
        streamPlaceholder.style.display = 'block';
    }
	




    
</script>
</body>
</html>
-->

<!-- index4.html 
<!DOCTYPE html>
<html>
<head>
    <title>Ruleta Americana - WebRTC P2P</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        #main-container, #capture-controls { display: none; }
        #login-container { text-align: center; margin-top: 50px; }
        .video-container { width: 100%; max-width: 600px; background-color: #000; border: 1px solid #ccc; position: relative; }
        #live-stream { width: 100%; display: block; }
        .video-placeholder { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #888; font-size: 1.5em; text-align: center; }
        #welcome-container {
            display: none;
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        #enter-game-button {
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        #enter-game-button:hover {
            background-color: #0056b3;
        }
        #tutorial-video {
            width: 50%;
            height: auto;
        }
    </style>
</head>
<body>
    <div id="login-container">
        <h1>Bienvenido a la Ruleta Americana</h1>
        <p>Por favor, ingresa tu nombre para continuar.</p>
        <form id="login-form"><input type="text" id="name-input" placeholder="Tu nombre" required><button type="submit">Ingresar</button></form>
    </div>
    <div id="welcome-container">
        <h1 id="welcome-message"></h1>
        <p>¡Todo listo para empezar!</p>
        <video id="tutorial-video" src="/static/color_wheel.mp4" controls></video>
        <button id="enter-game-button">ENTRAR AL JUEGO</button>
    </div>
    <div id="main-container">
        <h1>Ruleta Americana (Stream en Vivo - WebRTC)</h1>
        <div class="video-container">
            <video id="live-stream" autoplay muted playsinline></video>
            <div id="streamPlaceholder" class="video-placeholder">Esperando transmisión...</div>
        </div>
        <div id="capture-controls">
            <button id="startButton">INICIAR TRANSMISIÓN</button>
        </div>
    </div>

<script>
    // --- Referencias al DOM ---
    const loginContainer = document.getElementById('login-container');
    const mainContainer = document.getElementById('main-container');
    const loginForm = document.getElementById('login-form');
    const nameInput = document.getElementById('name-input');
    const startButton = document.getElementById('startButton');
    const captureControls = document.getElementById('capture-controls');
    const liveStreamVideo = document.getElementById('live-stream');
    const streamPlaceholder = document.getElementById('streamPlaceholder');
    const welcomeContainer = document.getElementById('welcome-container');
    const welcomeMessage = document.getElementById('welcome-message');
    const enterGameButton = document.getElementById('enter-game-button');

    // --- Estado Global y Configuración ---
    let ws = null;
    let userRole = "viewer";
    let isStreaming = false;
    let localStream;
    let peerConnections = {};
    let peerConnection;
    let currentUsername = '';
    let streamerId = ''; // Almacenar el ID real del streamer
    const pendingCandidates = {};

    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            {
                urls: 'turn:relay1.expressturn.com:3480',
                username: '000000002067441357',
                credential: 'ZWtqCZGCwebs2UeE8c8ryeqBHN8='
            }
        ]
    };

    // --- INICIO DEL FLUJO DE LA APLICACIÓN ---
    loginForm.onsubmit = (event) => {
        event.preventDefault();
        const username = nameInput.value.trim();
        if (username) {
            if (!ws || ws.readyState === WebSocket.CLOSED) {
                currentUsername = username;
                connectWebSocket(username);
            } else {
                console.log("Ya se está intentando una conexión.");
            }
        } else {
            alert("Por favor, ingresa un nombre.");
        }
    };

    enterGameButton.onclick = () => {
        console.log("Usuario ha entrado al juego. Mostrando contenedor principal.");
        welcomeContainer.style.display = 'none';
        mainContainer.style.display = 'block';

        if (userRole === 'streamer') {
            captureControls.style.display = 'block';
        }
        
        if (userRole === 'viewer' && isStreaming) {
            console.log("Stream ya está activo. Iniciando visualización...");
            startViewing();
        }
    };
	
	
    startButton.onclick = async () => {
        if (userRole === 'streamer' && !isStreaming) {
            try {
                //localStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
				//localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
				
				localStream = await navigator.mediaDevices.getUserMedia({
					video: {
						deviceId: undefined // Let the user select the OBS Virtual Camera
					},
					audio: true // Capture audio if needed (e.g., game sound or microphone)
				});
				
                console.log("Stream capturado:", localStream.getVideoTracks(), localStream.getAudioTracks());
                isStreaming = true;
                startButton.disabled = true;
                startButton.textContent = "TRANSMITIENDO...";
                liveStreamVideo.srcObject = localStream;
                liveStreamVideo.muted = true;
                showStream();

                // Notificar al servidor que el stream ha comenzado
                ws.send(JSON.stringify({ type: 'start_stream', from_id: currentUsername }));

                // Listener para cuando el streamer detiene la compartición
                localStream.getVideoTracks()[0].onended = () => {
                    console.log("Stream detenido por el usuario");
                    ws.send(JSON.stringify({ type: 'stream_ended', from_id: currentUsername }));
                    isStreaming = false;
                    startButton.disabled = false;
                    startButton.textContent = "INICIAR TRANSMISIÓN";
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                    Object.values(peerConnections).forEach(pc => pc.close());
                    peerConnections = {};
                };
            } catch (err) {
                console.error("Error al capturar pantalla o configurar stream:", err);
				//alert("No se pudo capturar la ventana seleccionada. Por favor, elige otra ventana o toda la pantalla.");
                isStreaming = false;
                startButton.disabled = false;
                startButton.textContent = "INICIAR TRANSMISIÓN";
            }
        }
    };
	
	/*
	startButton.onclick = async () => {
		if (isStreaming) return; // Prevent multiple clicks
		isStreaming = true;
		startButton.disabled = true;
		startButton.textContent = "CARGANDO...";

		try {
			// Capture the OBS Virtual Camera
			alert("Selecciona 'OBS-Camera' o 'OBS Virtual Camera' en el diálogo de selección de cámara.");
			localStream = await navigator.mediaDevices.getUserMedia({
				video: {
					deviceId: undefined // Let the user select the OBS Virtual Camera
				},
				audio: true // Capture audio if needed (e.g., game sound or microphone)
			});
			console.log("Pistas capturadas:", localStream.getVideoTracks(), localStream.getAudioTracks());

			if (localStream.getVideoTracks().length === 0) {
				alert("No se detectó video. Asegúrate de que OBS esté abierto, la cámara virtual esté activada, y selecciona 'OBS-Camera' en el diálogo.");
				isStreaming = false;
				startButton.disabled = false;
				startButton.textContent = "INICIAR TRANSMISIÓN";
				return;
			}

			// Notify server that streaming has started
			ws.send(JSON.stringify({ type: 'start_stream', from_id: currentUsername }));

			// Add tracks to the peer connection (assuming pc is your RTCPeerConnection)
			localStream.getTracks().forEach(track => {
				pc.addTrack(track, localStream);
			});

			// Handle stream ending
			localStream.getVideoTracks()[0].onended = () => {
				isStreaming = false;
				startButton.disabled = false;
				startButton.textContent = "INICIAR TRANSMISIÓN";
				ws.send(JSON.stringify({ type: 'stream_ended', from_id: currentUsername }));
			};
		} catch (err) {
			console.error("Error al capturar la cámara virtual de OBS:", err);
			alert("Error al capturar la cámara virtual. Asegúrate de que OBS esté abierto, la cámara virtual esté activada (Tools > VirtualCam > Start), y selecciona 'OBS-Camera' en el diálogo.");
			isStreaming = false;
			startButton.disabled = false;
			startButton.textContent = "INICIAR TRANSMISIÓN";
		}
	};
	*/
	
    // --- LÓGICA DE WEBSOCKET ---
    function connectWebSocket(username) {
        console.log("Intentando conectar WebSocket...");
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsHost = window.location.host;
        ws = new WebSocket(`${wsProtocol}//${wsHost}/ws/users`);

        let heartbeatInterval;

        ws.onopen = () => {
            console.log("Conectado al servidor. WebSocket está OPEN.");
            ws.send(JSON.stringify({ type: "login", name: username }));

            heartbeatInterval = setInterval(() => {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'ping' }));
                }
            }, 25000);
        };

        ws.onmessage = async (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'pong') return;
                console.log("Mensaje recibido:", data);

                switch (data.type) {
                    case 'login_success':
                        userRole = data.role;
                        streamerId = data.streamer_id || ''; // Obtener el ID del streamer
                        console.log(`Rol asignado: ${userRole}, Streamer ID: ${streamerId}`);
                        loginContainer.style.display = 'none';
                        welcomeContainer.style.display = 'block';
                        welcomeMessage.textContent = `¡Bienvenido, ${currentUsername}!`;
                        break;

                    case 'stream_started':
                        isStreaming = true;
                        console.log("Stream iniciado. Estado isStreaming:", isStreaming);
                        if (mainContainer.style.display === 'block' && userRole === 'viewer') {
                            showStream();
                            startViewing();
                        }
                        break;
                    
                    case 'stream_ended':
                        isStreaming = false;
                        console.log("Stream finalizado. Estado isStreaming:", isStreaming);
                        showPlaceholder("La transmisión ha finalizado.");
                        if (userRole === 'streamer') {
                            startButton.disabled = false;
                            startButton.textContent = "INICIAR TRANSMISIÓN";
                            if (localStream) localStream.getTracks().forEach(track => track.stop());
                            localStream = null;
                            Object.values(peerConnections).forEach(pc => pc.close());
                            peerConnections = {};
                        } else {
                            if (peerConnection) peerConnection.close();
                            peerConnection = null;
                            liveStreamVideo.srcObject = null;
                        }
                        break;

                    case 'offer':
                        if (userRole === 'streamer') {
                            console.log(`Oferta recibida de ${data.from_id}`);
                            await handleOffer(data.offer, data.from_id);
                        }
                        break;
                    case 'answer':
                        if (userRole === 'viewer') {
                            console.log(`Respuesta recibida de streamer`);
                            await handleAnswer(data.answer, data.from_id);
                        }
                        break;
                    case 'candidate':
                        console.log(`Candidato ICE recibido de ${data.from_id} para ${data.target_id}`);
                        await handleCandidate(data.candidate, data.from_id);
                        break;
                }
            } catch (e) {
                console.log("Mensaje de texto plano recibido:", event.data);
            }
        };

        ws.onclose = (event) => {
            console.log("Conexión cerrada.", event.code, event.reason);
            clearInterval(heartbeatInterval);
            ws = null;
            loginContainer.style.display = 'block';
            mainContainer.style.display = 'none';
            welcomeContainer.style.display = 'none';
            alert("Se ha perdido la conexión con el servidor. Por favor, ingresa de nuevo.");
        };

        ws.onerror = (error) => {
            console.error("Error en WebSocket:", error);
        };
    }

    // --- LÓGICA DE WEBRTC ---
    async function startViewing() {
        if (!streamerId) {
            console.error("No se ha recibido el ID del streamer. No se puede iniciar la visualización.");
            showPlaceholder("No hay streamer disponible.");
            return;
        }
        console.log("Iniciando conexión WebRTC como espectador...");
        peerConnection = new RTCPeerConnection(configuration);

        pendingCandidates['viewer'] = [];

        peerConnection.ontrack = (event) => {
            console.log("-> EVENTO ONTRACK DISPARADO");
            const remoteStream = event.streams[0];
            console.log("Pistas de video:", remoteStream.getVideoTracks());
            console.log("Pistas de audio:", remoteStream.getAudioTracks());

            if (liveStreamVideo.srcObject !== remoteStream) {
                console.log("Asignando nuevo stream al elemento de video.");
                liveStreamVideo.srcObject = remoteStream;
            }

            liveStreamVideo.muted = true;
            liveStreamVideo.playsInline = true;

            console.log("Intentando reproducir el video...");
            const playPromise = liveStreamVideo.play();

            if (playPromise !== undefined) {
                playPromise.then(() => {
                    console.log("¡La reproducción del video se inició con éxito!");
                    showStream();
                }).catch(error => {
                    console.error("La reproducción automática fue bloqueada:", error);
                    showPlaceholder("Transmisión lista. Haz clic aquí para reproducir.");

                    const playOnClick = () => {
                        console.log("Intentando reproducir por clic del usuario...");
                        liveStreamVideo.play().then(() => {
                            console.log("¡Reproducción iniciada por el usuario!");
                            showStream();
                            liveStreamVideo.removeEventListener('click', playOnClick);
                        }).catch(err => {
                            console.error("La reproducción por clic también falló:", err);
                        });
                    };
                    liveStreamVideo.addEventListener('click', playOnClick);
                });
            }
        };

        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log('Enviando candidato ICE:', event.candidate);
                ws.send(JSON.stringify({ 
                    type: 'candidate', 
                    candidate: event.candidate,
                    target_id: streamerId,
                    from_id: currentUsername
                }));
            }
        };

        peerConnection.onconnectionstatechange = () => {
            console.log("Estado de conexión WebRTC:", peerConnection.connectionState);
        };

        try {
            peerConnection.addTransceiver('video', {'direction': 'recvonly'});
            peerConnection.addTransceiver('audio', {'direction': 'recvonly'});
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            console.log("Oferta enviada:", peerConnection.localDescription);
            ws.send(JSON.stringify({ 
                type: 'offer', 
                offer: peerConnection.localDescription, 
                from_id: currentUsername, 
                target_id: streamerId 
            }));
            if (pendingCandidates['viewer'].length > 0) {
                console.log("Procesando candidatos pendientes para viewer...");
                for (const candidate of pendingCandidates['viewer']) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log("Candidato ICE añadido para viewer");
                }
                pendingCandidates['viewer'] = [];
            }
        } catch (error) {
            console.error("Error al crear o enviar la oferta:", error);
        }
    }

    async function handleOffer(offer, viewerId) {
        console.log(`Manejando oferta de ${viewerId}`);
        const pc = new RTCPeerConnection(configuration);
        peerConnections[viewerId] = pc;

        pendingCandidates[viewerId] = [];

        pc.onicecandidate = event => {
            if (event.candidate) {
                console.log(`Enviando candidato ICE para ${viewerId}:`, event.candidate);
                ws.send(JSON.stringify({ 
                    type: 'candidate', 
                    candidate: event.candidate,
                    target_id: viewerId,
                    from_id: currentUsername
                }));
            }
        };

        pc.onconnectionstatechange = () => {
            console.log(`Estado de conexión WebRTC para ${viewerId}:`, pc.connectionState);
        };

        try {
            await pc.setRemoteDescription(new RTCSessionDescription(offer));
            console.log(`remoteDescription configurada para ${viewerId}`);
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                    console.log(`Pista añadida para ${viewerId}: ${track.kind} (id: ${track.id})`);
                });
            } else {
                console.warn(`No hay localStream disponible para ${viewerId}`);
            }
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            console.log(`Respuesta enviada para ${viewerId}:`, answer);
            ws.send(JSON.stringify({ 
                type: 'answer', 
                answer: answer,
                target_id: viewerId,
                from_id: currentUsername
            }));
            if (pendingCandidates[viewerId].length > 0) {
                console.log(`Procesando candidatos pendientes para ${viewerId}...`);
                for (const candidate of pendingCandidates[viewerId]) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log(`Candidato ICE añadido para ${viewerId}`);
                }
                pendingCandidates[viewerId] = [];
            }
        } catch (error) {
            console.error(`Error manejando oferta de ${viewerId}:`, error);
        }
    }

    async function handleAnswer(answer, fromId) {
        const pc = peerConnection; // Viewer usa una sola peerConnection
        if (pc) {
            try {
                await pc.setRemoteDescription(new RTCSessionDescription(answer));
                console.log(`remoteDescription configurada para respuesta de ${fromId}`);
                if (pendingCandidates['viewer'].length > 0) {
                    console.log(`Procesando candidatos pendientes para viewer...`);
                    for (const candidate of pendingCandidates['viewer']) {
                        await pc.addIceCandidate(new RTCIceCandidate(candidate));
                        console.log(`Candidato ICE añadido para viewer`);
                    }
                    pendingCandidates['viewer'] = [];
                }
            } catch (error) {
                console.error(`Error manejando respuesta de ${fromId}:`, error);
            }
        } else {
            console.warn(`No se encontró peerConnection para el viewer`);
        }
    }

    async function handleCandidate(candidate, fromId) {
        const pc = (userRole === 'streamer') ? peerConnections[fromId] : peerConnection;
        if (pc) {
            try {
                if (pc.remoteDescription && pc.remoteDescription.type) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log(`Candidato ICE añadido para ${fromId}`);
                } else {
                    console.log(`remoteDescription no está lista para ${fromId}. Almacenando candidato...`);
                    if (!pendingCandidates[fromId] && userRole === 'streamer') {
                        pendingCandidates[fromId] = [];
                    } else if (!pendingCandidates['viewer'] && userRole === 'viewer') {
                        pendingCandidates['viewer'] = [];
                    }
                    (userRole === 'streamer' ? pendingCandidates[fromId] : pendingCandidates['viewer']).push(candidate);
                }
            } catch (e) {
                console.error(`Error añadiendo candidato ICE para ${fromId}:`, e);
            }
        } else {
            console.warn(`No se encontró peerConnection para ${fromId}`);
        }
    }

    // --- Funciones de UI ---
    function showStream() {
        liveStreamVideo.style.visibility = 'visible';
        streamPlaceholder.style.display = 'none';
    }

    function showPlaceholder(message) {
        liveStreamVideo.style.visibility = 'hidden';
        streamPlaceholder.textContent = message;
        streamPlaceholder.style.display = 'block';
    }
</script>
</body>
</html>
-->

<!-- index4.html  -->
<!DOCTYPE html>
<html>
<head>
    <title>Ruleta Americana - WebRTC P2P</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        #main-container, #capture-controls { display: none; }
        #login-container { text-align: center; margin-top: 50px; }
        .video-container { width: 100%; max-width: 600px; background-color: #000; border: 1px solid #ccc; position: relative; }
        #live-stream { width: 100%; display: block; }
        .video-placeholder { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #888; font-size: 1.5em; text-align: center; }
        #welcome-container {
            display: none;
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        #enter-game-button {
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        #enter-game-button:hover {
            background-color: #0056b3;
        }
        #tutorial-video {
            width: 50%;
            height: auto;
        }
    </style>
</head>
<body>
    <div id="login-container">
        <h1>Bienvenido a la Ruleta Americana</h1>
        <p>Por favor, ingresa tu nombre para continuar.</p>
        <form id="login-form"><input type="text" id="name-input" placeholder="Tu nombre" required><button type="submit">Ingresar</button></form>
    </div>
    <div id="welcome-container">
        <h1 id="welcome-message"></h1>
        <p>¡Todo listo para empezar!</p>
        <video id="tutorial-video" src="/static/color_wheel.mp4" controls></video>
        <button id="enter-game-button">ENTRAR AL JUEGO</button>
    </div>
    <div id="main-container">
        <h1>Ruleta Americana (Stream en Vivo - WebRTC)</h1>
        <div class="video-container">
            <video id="live-stream" autoplay muted playsinline></video>
            <div id="streamPlaceholder" class="video-placeholder">Esperando transmisión...</div>
        </div>
        <div id="capture-controls">
            <button id="startButton">INICIAR TRANSMISIÓN</button>
        </div>
    </div>

<script>
    // --- Referencias al DOM ---
    const loginContainer = document.getElementById('login-container');
    const mainContainer = document.getElementById('main-container');
    const loginForm = document.getElementById('login-form');
    const nameInput = document.getElementById('name-input');
    const startButton = document.getElementById('startButton');
    const captureControls = document.getElementById('capture-controls');
    const liveStreamVideo = document.getElementById('live-stream');
    const streamPlaceholder = document.getElementById('streamPlaceholder');
    const welcomeContainer = document.getElementById('welcome-container');
    const welcomeMessage = document.getElementById('welcome-message');
    const enterGameButton = document.getElementById('enter-game-button');

    // --- Estado Global y Configuración ---
    let ws = null;
    let userRole = "viewer";
    let isStreaming = false;
    let localStream;
    let peerConnections = {};
    let peerConnection;
    let currentUsername = '';
    let streamerId = ''; // Almacenar el ID real del streamer
    const pendingCandidates = {};

    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            {
                urls: 'turn:relay1.expressturn.com:3480',
                username: '000000002067441357',
                credential: 'ZWtqCZGCwebs2UeE8c8ryeqBHN8='
            }
        ]
    };

    // --- INICIO DEL FLUJO DE LA APLICACIÓN ---
    loginForm.onsubmit = (event) => {
        event.preventDefault();
        const username = nameInput.value.trim();
        if (username) {
            if (!ws || ws.readyState === WebSocket.CLOSED) {
                currentUsername = username;
                connectWebSocket(username);
            } else {
                console.log("Ya se está intentando una conexión.");
            }
        } else {
            alert("Por favor, ingresa un nombre.");
        }
    };

    enterGameButton.onclick = () => {
        console.log("Usuario ha entrado al juego. Mostrando contenedor principal.");
        welcomeContainer.style.display = 'none';
        mainContainer.style.display = 'block';

        if (userRole === 'streamer') {
            captureControls.style.display = 'block';
        }
        
        if (userRole === 'viewer' && isStreaming) {
            console.log("Stream ya está activo. Iniciando visualización...");
            startViewing();
        }
    };

    startButton.onclick = async () => {
		alert("ENTRA")
        //if (userRole === 'streamer' && !isStreaming) {
            try {
                localStream = await navigator.mediaDevices.getDisplayMedia({ video: true});
                console.log("Stream capturado:", localStream.getVideoTracks(), localStream.getAudioTracks());
                isStreaming = true;
                startButton.disabled = true;
                startButton.textContent = "TRANSMITIENDO...";
                liveStreamVideo.srcObject = localStream;
                liveStreamVideo.muted = true;
                showStream();

                // Notificar al servidor que el stream ha comenzado
                ws.send(JSON.stringify({ type: 'start_stream', from_id: currentUsername }));

                // Listener para cuando el streamer detiene la compartición
                localStream.getVideoTracks()[0].onended = () => {
                    console.log("Stream detenido por el usuario");
                    ws.send(JSON.stringify({ type: 'stream_ended', from_id: currentUsername }));
                    isStreaming = false;
                    startButton.disabled = false;
                    startButton.textContent = "INICIAR TRANSMISIÓN";
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                    Object.values(peerConnections).forEach(pc => pc.close());
                    peerConnections = {};
                };
            } catch (err) {
                console.error("Error al capturar pantalla o configurar stream:", err);
                isStreaming = false;
                startButton.disabled = false;
                startButton.textContent = "INICIAR TRANSMISIÓN";
            }
        //}
    };

    // --- LÓGICA DE WEBSOCKET ---
    function connectWebSocket(username) {
        console.log("Intentando conectar WebSocket...");
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsHost = window.location.host;
        ws = new WebSocket(`${wsProtocol}//${wsHost}/ws/users`);

        let heartbeatInterval;

        ws.onopen = () => {
            console.log("Conectado al servidor. WebSocket está OPEN.");
            ws.send(JSON.stringify({ type: "login", name: username }));

            heartbeatInterval = setInterval(() => {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'ping' }));
                }
            }, 25000);
        };

        ws.onmessage = async (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'pong') return;
                console.log("Mensaje recibido:", data);

                switch (data.type) {
                    case 'login_success':
                        userRole = data.role;
                        streamerId = data.streamer_id || ''; // Obtener el ID del streamer
                        console.log(`Rol asignado: ${userRole}, Streamer ID: ${streamerId}`);
                        loginContainer.style.display = 'none';
                        welcomeContainer.style.display = 'block';
                        welcomeMessage.textContent = `¡Bienvenido, ${currentUsername}!`;
                        break;

                    case 'stream_started':
                        isStreaming = true;
                        console.log("Stream iniciado. Estado isStreaming:", isStreaming);
                        if (mainContainer.style.display === 'block' && userRole === 'viewer') {
                            showStream();
                            startViewing();
                        }
                        break;
                    
                    case 'stream_ended':
                        isStreaming = false;
                        console.log("Stream finalizado. Estado isStreaming:", isStreaming);
                        showPlaceholder("La transmisión ha finalizado.");
                        if (userRole === 'streamer') {
                            startButton.disabled = false;
                            startButton.textContent = "INICIAR TRANSMISIÓN";
                            if (localStream) localStream.getTracks().forEach(track => track.stop());
                            localStream = null;
                            Object.values(peerConnections).forEach(pc => pc.close());
                            peerConnections = {};
                        } else {
                            if (peerConnection) peerConnection.close();
                            peerConnection = null;
                            liveStreamVideo.srcObject = null;
                        }
                        break;

                    case 'offer':
                        if (userRole === 'streamer') {
                            console.log(`Oferta recibida de ${data.from_id}`);
                            await handleOffer(data.offer, data.from_id);
                        }
                        break;
                    case 'answer':
                        if (userRole === 'viewer') {
                            console.log(`Respuesta recibida de streamer`);
                            await handleAnswer(data.answer, data.from_id);
                        }
                        break;
                    case 'candidate':
                        console.log(`Candidato ICE recibido de ${data.from_id} para ${data.target_id}`);
                        await handleCandidate(data.candidate, data.from_id);
                        break;
                }
            } catch (e) {
                console.log("Mensaje de texto plano recibido:", event.data);
            }
        };

        ws.onclose = (event) => {
            console.log("Conexión cerrada.", event.code, event.reason);
            clearInterval(heartbeatInterval);
            ws = null;
            loginContainer.style.display = 'block';
            mainContainer.style.display = 'none';
            welcomeContainer.style.display = 'none';
            alert("Se ha perdido la conexión con el servidor. Por favor, ingresa de nuevo.");
        };

        ws.onerror = (error) => {
            console.error("Error en WebSocket:", error);
        };
    }

    // --- LÓGICA DE WEBRTC ---
    async function startViewing() {
        if (!streamerId) {
            console.error("No se ha recibido el ID del streamer. No se puede iniciar la visualización.");
            showPlaceholder("No hay streamer disponible.");
            return;
        }
        console.log("Iniciando conexión WebRTC como espectador...");
        peerConnection = new RTCPeerConnection(configuration);

        pendingCandidates['viewer'] = [];

        peerConnection.ontrack = (event) => {
            console.log("-> EVENTO ONTRACK DISPARADO");
            const remoteStream = event.streams[0];
            console.log("Pistas de video:", remoteStream.getVideoTracks());
            console.log("Pistas de audio:", remoteStream.getAudioTracks());

            if (liveStreamVideo.srcObject !== remoteStream) {
                console.log("Asignando nuevo stream al elemento de video.");
                liveStreamVideo.srcObject = remoteStream;
            }

            liveStreamVideo.muted = true;
            liveStreamVideo.playsInline = true;

            console.log("Intentando reproducir el video...");
            const playPromise = liveStreamVideo.play();

            if (playPromise !== undefined) {
                playPromise.then(() => {
                    console.log("¡La reproducción del video se inició con éxito!");
                    showStream();
                }).catch(error => {
                    console.error("La reproducción automática fue bloqueada:", error);
                    showPlaceholder("Transmisión lista. Haz clic aquí para reproducir.");

                    const playOnClick = () => {
                        console.log("Intentando reproducir por clic del usuario...");
                        liveStreamVideo.play().then(() => {
                            console.log("¡Reproducción iniciada por el usuario!");
                            showStream();
                            liveStreamVideo.removeEventListener('click', playOnClick);
                        }).catch(err => {
                            console.error("La reproducción por clic también falló:", err);
                        });
                    };
                    liveStreamVideo.addEventListener('click', playOnClick);
                });
            }
        };

        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log('Enviando candidato ICE:', event.candidate);
                ws.send(JSON.stringify({ 
                    type: 'candidate', 
                    candidate: event.candidate,
                    target_id: streamerId,
                    from_id: currentUsername
                }));
            }
        };

        peerConnection.onconnectionstatechange = () => {
            console.log("Estado de conexión WebRTC:", peerConnection.connectionState);
        };

        try {
            peerConnection.addTransceiver('video', {'direction': 'recvonly'});
            peerConnection.addTransceiver('audio', {'direction': 'recvonly'});
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            console.log("Oferta enviada:", peerConnection.localDescription);
            ws.send(JSON.stringify({ 
                type: 'offer', 
                offer: peerConnection.localDescription, 
                from_id: currentUsername, 
                target_id: streamerId 
            }));
            if (pendingCandidates['viewer'].length > 0) {
                console.log("Procesando candidatos pendientes para viewer...");
                for (const candidate of pendingCandidates['viewer']) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log("Candidato ICE añadido para viewer");
                }
                pendingCandidates['viewer'] = [];
            }
        } catch (error) {
            console.error("Error al crear o enviar la oferta:", error);
        }
    }

    async function handleOffer(offer, viewerId) {
        console.log(`Manejando oferta de ${viewerId}`);
        const pc = new RTCPeerConnection(configuration);
        peerConnections[viewerId] = pc;

        pendingCandidates[viewerId] = [];

        pc.onicecandidate = event => {
            if (event.candidate) {
                console.log(`Enviando candidato ICE para ${viewerId}:`, event.candidate);
                ws.send(JSON.stringify({ 
                    type: 'candidate', 
                    candidate: event.candidate,
                    target_id: viewerId,
                    from_id: currentUsername
                }));
            }
        };

        pc.onconnectionstatechange = () => {
            console.log(`Estado de conexión WebRTC para ${viewerId}:`, pc.connectionState);
        };

        try {
            await pc.setRemoteDescription(new RTCSessionDescription(offer));
            console.log(`remoteDescription configurada para ${viewerId}`);
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                    console.log(`Pista añadida para ${viewerId}: ${track.kind} (id: ${track.id})`);
                });
            } else {
                console.warn(`No hay localStream disponible para ${viewerId}`);
            }
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            console.log(`Respuesta enviada para ${viewerId}:`, answer);
            ws.send(JSON.stringify({ 
                type: 'answer', 
                answer: answer,
                target_id: viewerId,
                from_id: currentUsername
            }));
            if (pendingCandidates[viewerId].length > 0) {
                console.log(`Procesando candidatos pendientes para ${viewerId}...`);
                for (const candidate of pendingCandidates[viewerId]) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log(`Candidato ICE añadido para ${viewerId}`);
                }
                pendingCandidates[viewerId] = [];
            }
        } catch (error) {
            console.error(`Error manejando oferta de ${viewerId}:`, error);
        }
    }

    async function handleAnswer(answer, fromId) {
        const pc = peerConnection; // Viewer usa una sola peerConnection
        if (pc) {
            try {
                await pc.setRemoteDescription(new RTCSessionDescription(answer));
                console.log(`remoteDescription configurada para respuesta de ${fromId}`);
                if (pendingCandidates['viewer'].length > 0) {
                    console.log(`Procesando candidatos pendientes para viewer...`);
                    for (const candidate of pendingCandidates['viewer']) {
                        await pc.addIceCandidate(new RTCIceCandidate(candidate));
                        console.log(`Candidato ICE añadido para viewer`);
                    }
                    pendingCandidates['viewer'] = [];
                }
            } catch (error) {
                console.error(`Error manejando respuesta de ${fromId}:`, error);
            }
        } else {
            console.warn(`No se encontró peerConnection para el viewer`);
        }
    }

    async function handleCandidate(candidate, fromId) {
        const pc = (userRole === 'streamer') ? peerConnections[fromId] : peerConnection;
        if (pc) {
            try {
                if (pc.remoteDescription && pc.remoteDescription.type) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log(`Candidato ICE añadido para ${fromId}`);
                } else {
                    console.log(`remoteDescription no está lista para ${fromId}. Almacenando candidato...`);
                    if (!pendingCandidates[fromId] && userRole === 'streamer') {
                        pendingCandidates[fromId] = [];
                    } else if (!pendingCandidates['viewer'] && userRole === 'viewer') {
                        pendingCandidates['viewer'] = [];
                    }
                    (userRole === 'streamer' ? pendingCandidates[fromId] : pendingCandidates['viewer']).push(candidate);
                }
            } catch (e) {
                console.error(`Error añadiendo candidato ICE para ${fromId}:`, e);
            }
        } else {
            console.warn(`No se encontró peerConnection para ${fromId}`);
        }
    }

    // --- Funciones de UI ---
    function showStream() {
        liveStreamVideo.style.visibility = 'visible';
        streamPlaceholder.style.display = 'none';
    }

    function showPlaceholder(message) {
        liveStreamVideo.style.visibility = 'hidden';
        streamPlaceholder.textContent = message;
        streamPlaceholder.style.display = 'block';
    }
</script>
</body>
</html>