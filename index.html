<!-- index.html
<!DOCTYPE html>
<html>
<head>
    <title>Ruleta Americana - WebRTC P2P</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        #main-container, #capture-controls { display: none; }
        #login-container { text-align: center; margin-top: 50px; }
        .video-container { width: 100%; max-width: 600px; background-color: #000; border: 1px solid #ccc; position: relative; }
        #live-stream { width: 100%; display: block; }
        .video-placeholder { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #888; font-size: 1.5em; text-align: center; }
        #welcome-container {
            display: none;
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        #enter-game-button {
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        #enter-game-button:hover {
            background-color: #0056b3;
        }
        #tutorial-video {
            width: 50%;
            height: auto;
        }
    </style>
</head>
<body>
    <div id="login-container">
        <h1>Bienvenido a la Ruleta Americana</h1>
        <p>Por favor, ingresa tu nombre para continuar.</p>
        <form id="login-form"><input type="text" id="name-input" placeholder="Tu nombre" required><button type="submit">Ingresar</button></form>
    </div>
    <div id="welcome-container">
        <h1 id="welcome-message"></h1>
        <p>¡Todo listo para empezar!</p>
        <video id="tutorial-video" src="/static/color_wheel.mp4" controls></video>
        <button id="enter-game-button">ENTRAR AL JUEGO</button>
    </div>
    <div id="main-container">
        <h1>Ruleta Americana (Stream en Vivo - WebRTC)</h1>
        <div class="video-container">
            <video id="live-stream" autoplay muted playsinline></video>
            <div id="streamPlaceholder" class="video-placeholder">Esperando transmisión...</div>
        </div>
        <div id="capture-controls">
            <button id="startButton">INICIAR TRANSMISIÓN</button>
        </div>
    </div>

<script>
    // --- Referencias al DOM ---
    const loginContainer = document.getElementById('login-container');
    const mainContainer = document.getElementById('main-container');
    const loginForm = document.getElementById('login-form');
    const nameInput = document.getElementById('name-input');
    const startButton = document.getElementById('startButton');
    const captureControls = document.getElementById('capture-controls');
    const liveStreamVideo = document.getElementById('live-stream');
    const streamPlaceholder = document.getElementById('streamPlaceholder');
    const welcomeContainer = document.getElementById('welcome-container');
    const welcomeMessage = document.getElementById('welcome-message');
    const enterGameButton = document.getElementById('enter-game-button');

    // --- Estado Global y Configuración ---
    let ws = null;
    let userRole = "viewer";
    let isStreaming = false;
    let localStream;
    let peerConnections = {};
    let peerConnection;
    let currentUsername = '';
    let streamerId = ''; // Almacenar el ID real del streamer
    const pendingCandidates = {};

    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            {
                urls: 'turn:relay1.expressturn.com:3480',
                username: '000000002067441357',
                credential: 'ZWtqCZGCwebs2UeE8c8ryeqBHN8='
            }
        ]
    };

    // --- INICIO DEL FLUJO DE LA APLICACIÓN ---
    loginForm.onsubmit = (event) => {
        event.preventDefault();
        const username = nameInput.value.trim();
        if (username) {
            if (!ws || ws.readyState === WebSocket.CLOSED) {
                currentUsername = username;
                connectWebSocket(username);
            } else {
                console.log("Ya se está intentando una conexión.");
            }
        } else {
            alert("Por favor, ingresa un nombre.");
        }
    };

    enterGameButton.onclick = () => {
        console.log("Usuario ha entrado al juego. Mostrando contenedor principal.");
        welcomeContainer.style.display = 'none';
        mainContainer.style.display = 'block';

        if (userRole === 'streamer') {
            captureControls.style.display = 'block';
        }
        
        if (userRole === 'viewer' && isStreaming) {
            console.log("Stream ya está activo. Iniciando visualización...");
            startViewing();
        }
    };
	
	
    startButton.onclick = async () => {
        if (userRole === 'streamer' && !isStreaming) {
            try {
                localStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
				//localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
				/*
				localStream = await navigator.mediaDevices.getUserMedia({
					video: {
						deviceId: undefined // Let the user select the OBS Virtual Camera
					},
					audio: true // Capture audio if needed (e.g., game sound or microphone)
				});
				*/
                console.log("Stream capturado:", localStream.getVideoTracks(), localStream.getAudioTracks());
                isStreaming = true;
                startButton.disabled = true;
                startButton.textContent = "TRANSMITIENDO...";
                liveStreamVideo.srcObject = localStream;
                liveStreamVideo.muted = true;
                showStream();

                // Notificar al servidor que el stream ha comenzado
                ws.send(JSON.stringify({ type: 'start_stream', from_id: currentUsername }));

                // Listener para cuando el streamer detiene la compartición
                localStream.getVideoTracks()[0].onended = () => {
                    console.log("Stream detenido por el usuario");
                    ws.send(JSON.stringify({ type: 'stream_ended', from_id: currentUsername }));
                    isStreaming = false;
                    startButton.disabled = false;
                    startButton.textContent = "INICIAR TRANSMISIÓN";
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                    Object.values(peerConnections).forEach(pc => pc.close());
                    peerConnections = {};
                };
            } catch (err) {
                console.error("Error al capturar pantalla o configurar stream:", err);
				alert("No se pudo capturar la ventana seleccionada. Por favor, elige otra ventana o toda la pantalla.");
                isStreaming = false;
                startButton.disabled = false;
                startButton.textContent = "INICIAR TRANSMISIÓN";
            }
        }
    };
	
	
    // --- LÓGICA DE WEBSOCKET ---
    function connectWebSocket(username) {
        console.log("Intentando conectar WebSocket...");
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsHost = window.location.host;
        ws = new WebSocket(`${wsProtocol}//${wsHost}/ws/users`);

        let heartbeatInterval;

        ws.onopen = () => {
            console.log("Conectado al servidor. WebSocket está OPEN.");
            ws.send(JSON.stringify({ type: "login", name: username }));

            heartbeatInterval = setInterval(() => {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'ping' }));
                }
            }, 25000);
        };

        ws.onmessage = async (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'pong') return;
                console.log("Mensaje recibido:", data);

                switch (data.type) {
                    case 'login_success':
                        userRole = data.role;
                        streamerId = data.streamer_id || ''; // Obtener el ID del streamer
                        console.log(`Rol asignado: ${userRole}, Streamer ID: ${streamerId}`);
                        loginContainer.style.display = 'none';
                        welcomeContainer.style.display = 'block';
                        welcomeMessage.textContent = `¡Bienvenido, ${currentUsername}!`;
                        break;

                    case 'stream_started':
                        isStreaming = true;
                        console.log("Stream iniciado. Estado isStreaming:", isStreaming);
                        if (mainContainer.style.display === 'block' && userRole === 'viewer') {
                            showStream();
                            startViewing();
                        }
                        break;
                    
                    case 'stream_ended':
                        isStreaming = false;
                        console.log("Stream finalizado. Estado isStreaming:", isStreaming);
                        showPlaceholder("La transmisión ha finalizado.");
                        if (userRole === 'streamer') {
                            startButton.disabled = false;
                            startButton.textContent = "INICIAR TRANSMISIÓN";
                            if (localStream) localStream.getTracks().forEach(track => track.stop());
                            localStream = null;
                            Object.values(peerConnections).forEach(pc => pc.close());
                            peerConnections = {};
                        } else {
                            if (peerConnection) peerConnection.close();
                            peerConnection = null;
                            liveStreamVideo.srcObject = null;
                        }
                        break;

                    case 'offer':
                        if (userRole === 'streamer') {
                            console.log(`Oferta recibida de ${data.from_id}`);
                            await handleOffer(data.offer, data.from_id);
                        }
                        break;
                    case 'answer':
                        if (userRole === 'viewer') {
                            console.log(`Respuesta recibida de streamer`);
                            await handleAnswer(data.answer, data.from_id);
                        }
                        break;
                    case 'candidate':
                        console.log(`Candidato ICE recibido de ${data.from_id} para ${data.target_id}`);
                        await handleCandidate(data.candidate, data.from_id);
                        break;
                }
            } catch (e) {
                console.log("Mensaje de texto plano recibido:", event.data);
            }
        };

        ws.onclose = (event) => {
            console.log("Conexión cerrada.", event.code, event.reason);
            clearInterval(heartbeatInterval);
            ws = null;
            loginContainer.style.display = 'block';
            mainContainer.style.display = 'none';
            welcomeContainer.style.display = 'none';
            alert("Se ha perdido la conexión con el servidor. Por favor, ingresa de nuevo.");
        };

        ws.onerror = (error) => {
            console.error("Error en WebSocket:", error);
        };
    }

    // --- LÓGICA DE WEBRTC ---
    async function startViewing() {
        if (!streamerId) {
            console.error("No se ha recibido el ID del streamer. No se puede iniciar la visualización.");
            showPlaceholder("No hay streamer disponible.");
            return;
        }
        console.log("Iniciando conexión WebRTC como espectador...");
        peerConnection = new RTCPeerConnection(configuration);

        pendingCandidates['viewer'] = [];

        peerConnection.ontrack = (event) => {
            console.log("-> EVENTO ONTRACK DISPARADO");
            const remoteStream = event.streams[0];
            console.log("Pistas de video:", remoteStream.getVideoTracks());
            console.log("Pistas de audio:", remoteStream.getAudioTracks());

            if (liveStreamVideo.srcObject !== remoteStream) {
                console.log("Asignando nuevo stream al elemento de video.");
                liveStreamVideo.srcObject = remoteStream;
            }

            liveStreamVideo.muted = true;
            liveStreamVideo.playsInline = true;

            console.log("Intentando reproducir el video...");
            const playPromise = liveStreamVideo.play();

            if (playPromise !== undefined) {
                playPromise.then(() => {
                    console.log("¡La reproducción del video se inició con éxito!");
                    showStream();
                }).catch(error => {
                    console.error("La reproducción automática fue bloqueada:", error);
                    showPlaceholder("Transmisión lista. Haz clic aquí para reproducir.");

                    const playOnClick = () => {
                        console.log("Intentando reproducir por clic del usuario...");
                        liveStreamVideo.play().then(() => {
                            console.log("¡Reproducción iniciada por el usuario!");
                            showStream();
                            liveStreamVideo.removeEventListener('click', playOnClick);
                        }).catch(err => {
                            console.error("La reproducción por clic también falló:", err);
                        });
                    };
                    liveStreamVideo.addEventListener('click', playOnClick);
                });
            }
        };

        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log('Enviando candidato ICE:', event.candidate);
                ws.send(JSON.stringify({ 
                    type: 'candidate', 
                    candidate: event.candidate,
                    target_id: streamerId,
                    from_id: currentUsername
                }));
            }
        };

        peerConnection.onconnectionstatechange = () => {
            console.log("Estado de conexión WebRTC:", peerConnection.connectionState);
        };

        try {
            peerConnection.addTransceiver('video', {'direction': 'recvonly'});
            peerConnection.addTransceiver('audio', {'direction': 'recvonly'});
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            console.log("Oferta enviada:", peerConnection.localDescription);
            ws.send(JSON.stringify({ 
                type: 'offer', 
                offer: peerConnection.localDescription, 
                from_id: currentUsername, 
                target_id: streamerId 
            }));
            if (pendingCandidates['viewer'].length > 0) {
                console.log("Procesando candidatos pendientes para viewer...");
                for (const candidate of pendingCandidates['viewer']) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log("Candidato ICE añadido para viewer");
                }
                pendingCandidates['viewer'] = [];
            }
        } catch (error) {
            console.error("Error al crear o enviar la oferta:", error);
        }
    }

    async function handleOffer(offer, viewerId) {
        console.log(`Manejando oferta de ${viewerId}`);
        const pc = new RTCPeerConnection(configuration);
        peerConnections[viewerId] = pc;

        pendingCandidates[viewerId] = [];

        pc.onicecandidate = event => {
            if (event.candidate) {
                console.log(`Enviando candidato ICE para ${viewerId}:`, event.candidate);
                ws.send(JSON.stringify({ 
                    type: 'candidate', 
                    candidate: event.candidate,
                    target_id: viewerId,
                    from_id: currentUsername
                }));
            }
        };

        pc.onconnectionstatechange = () => {
            console.log(`Estado de conexión WebRTC para ${viewerId}:`, pc.connectionState);
        };

        try {
            await pc.setRemoteDescription(new RTCSessionDescription(offer));
            console.log(`remoteDescription configurada para ${viewerId}`);
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                    console.log(`Pista añadida para ${viewerId}: ${track.kind} (id: ${track.id})`);
                });
            } else {
                console.warn(`No hay localStream disponible para ${viewerId}`);
            }
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            console.log(`Respuesta enviada para ${viewerId}:`, answer);
            ws.send(JSON.stringify({ 
                type: 'answer', 
                answer: answer,
                target_id: viewerId,
                from_id: currentUsername
            }));
            if (pendingCandidates[viewerId].length > 0) {
                console.log(`Procesando candidatos pendientes para ${viewerId}...`);
                for (const candidate of pendingCandidates[viewerId]) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log(`Candidato ICE añadido para ${viewerId}`);
                }
                pendingCandidates[viewerId] = [];
            }
        } catch (error) {
            console.error(`Error manejando oferta de ${viewerId}:`, error);
        }
    }

    async function handleAnswer(answer, fromId) {
        const pc = peerConnection; // Viewer usa una sola peerConnection
        if (pc) {
            try {
                await pc.setRemoteDescription(new RTCSessionDescription(answer));
                console.log(`remoteDescription configurada para respuesta de ${fromId}`);
                if (pendingCandidates['viewer'].length > 0) {
                    console.log(`Procesando candidatos pendientes para viewer...`);
                    for (const candidate of pendingCandidates['viewer']) {
                        await pc.addIceCandidate(new RTCIceCandidate(candidate));
                        console.log(`Candidato ICE añadido para viewer`);
                    }
                    pendingCandidates['viewer'] = [];
                }
            } catch (error) {
                console.error(`Error manejando respuesta de ${fromId}:`, error);
            }
        } else {
            console.warn(`No se encontró peerConnection para el viewer`);
        }
    }

    async function handleCandidate(candidate, fromId) {
        const pc = (userRole === 'streamer') ? peerConnections[fromId] : peerConnection;
        if (pc) {
            try {
                if (pc.remoteDescription && pc.remoteDescription.type) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log(`Candidato ICE añadido para ${fromId}`);
                } else {
                    console.log(`remoteDescription no está lista para ${fromId}. Almacenando candidato...`);
                    if (!pendingCandidates[fromId] && userRole === 'streamer') {
                        pendingCandidates[fromId] = [];
                    } else if (!pendingCandidates['viewer'] && userRole === 'viewer') {
                        pendingCandidates['viewer'] = [];
                    }
                    (userRole === 'streamer' ? pendingCandidates[fromId] : pendingCandidates['viewer']).push(candidate);
                }
            } catch (e) {
                console.error(`Error añadiendo candidato ICE para ${fromId}:`, e);
            }
        } else {
            console.warn(`No se encontró peerConnection para ${fromId}`);
        }
    }

    // --- Funciones de UI ---
    function showStream() {
        liveStreamVideo.style.visibility = 'visible';
        streamPlaceholder.style.display = 'none';
    }

    function showPlaceholder(message) {
        liveStreamVideo.style.visibility = 'hidden';
        streamPlaceholder.textContent = message;
        streamPlaceholder.style.display = 'block';
    }
</script>
</body>
</html>
-->

<!-- index.html
<!DOCTYPE html>
<html>
<head>
    <title>Ruleta Americana - WebRTC P2P</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        #main-container, #capture-controls { display: none; }
        #login-container { text-align: center; margin-top: 50px; }
        .video-container { width: 100%; max-width: 600px; background-color: #000; border: 1px solid #ccc; position: relative; }
        #live-stream { width: 100%; display: block; }
        .video-placeholder { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #888; font-size: 1.5em; text-align: center; }
        #welcome-container {
            display: none;
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        #enter-game-button {
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        #enter-game-button:hover {
            background-color: #0056b3;
        }
        #tutorial-video {
            width: 50%;
            height: auto;
        }
    </style>
</head>
<body>
    <div id="login-container">
        <h1>Bienvenido a la Ruleta Americana</h1>
        <p>Por favor, ingresa tu nombre para continuar.</p>
        <form id="login-form"><input type="text" id="name-input" placeholder="Tu nombre" required><button type="submit">Ingresar</button></form>
    </div>
    <div id="welcome-container">
        <h1 id="welcome-message"></h1>
        <p>¡Todo listo para empezar!</p>
        <video id="tutorial-video" src="/static/color_wheel.mp4" controls></video>
        <button id="enter-game-button">ENTRAR AL JUEGO</button>
    </div>
    <div id="main-container">
        <h1>Ruleta Americana (Stream en Vivo - WebRTC)</h1>
        <div class="video-container">
            <video id="live-stream" autoplay muted playsinline></video>
            <div id="streamPlaceholder" class="video-placeholder">Esperando transmisión...</div>
        </div>
        <div id="capture-controls">
            <button id="startButton">INICIAR TRANSMISIÓN</button>
        </div>
    </div>

<script>
    // Referencias al DOM
    const loginContainer = document.getElementById('login-container');
    const mainContainer = document.getElementById('main-container');
    const loginForm = document.getElementById('login-form');
    const nameInput = document.getElementById('name-input');
    const startButton = document.getElementById('startButton');
    const captureControls = document.getElementById('capture-controls');
    const liveStreamVideo = document.getElementById('live-stream');
    const streamPlaceholder = document.getElementById('streamPlaceholder');
    const welcomeContainer = document.getElementById('welcome-container');
    const welcomeMessage = document.getElementById('welcome-message');
    const enterGameButton = document.getElementById('enter-game-button');

    // Estado Global y Configuración
    let ws = null;
    let userRole = "viewer";
    let isStreaming = false;
    let localStream;
    let peerConnections = {};
    let streamerId = ''; // Almacenar el ID real del streamer
    const pendingCandidates = {};

    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            {
                urls: 'turn:relay1.expressturn.com:3480',
                username: '000000002067441357',
                credential: 'ZWtqCZGCwebs2UeE8c8ryeqBHN8='
            }
        ]
    };

    // INICIO DEL FLUJO DE LA APLICACIÓN
    loginForm.onsubmit = (event) => {
        event.preventDefault();
        const username = nameInput.value.trim();
        if (username) {
            if (!ws || ws.readyState === WebSocket.CLOSED) {
                currentUsername = username;
                connectWebSocket(username);
            } else {
                console.log("Ya se está intentando una conexión.");
            }
        } else {
            alert("Por favor, ingresa un nombre.");
        }
    };

    enterGameButton.onclick = () => {
        console.log("Usuario ha entrado al juego. Mostrando contenedor principal.");
        welcomeContainer.style.display = 'none';
        mainContainer.style.display = 'block';

        if (userRole === 'streamer') {
            captureControls.style.display = 'block';
        }
        
        if (userRole === 'viewer' && isStreaming) {
            console.log("Stream ya está activo. Iniciando visualización...");
            startViewing();
        }
    };

    startButton.onclick = async () => {
        // Deshabilitar el botón temporalmente para evitar clics rápidos
        startButton.disabled = true;
        startButton.textContent = "CARGANDO...";

        try {
            // Liberar el stream anterior y conexiones WebRTC para forzar el diálogo
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                console.log("Stream anterior liberado para forzar el diálogo de selección.");
            }
            Object.values(peerConnections).forEach(pc => pc.close());
            peerConnections = {};

            // Mostrar mensaje en la UI para guiar al usuario
            showPlaceholder("Selecciona 'OBS-Camera' o 'OBS Virtual Camera' en el diálogo.");

            // Forzar el diálogo de selección de cámara virtual de OBS
            localStream = await navigator.mediaDevices.getUserMedia({
                video: { deviceId: { exact: undefined } },
                audio: true // Capturar audio si es necesario (ej. sonido del juego o micrófono)
            });
            console.log("Pistas capturadas:", localStream.getVideoTracks(), localStream.getAudioTracks());

            // Verificar si se capturó video
            if (localStream.getVideoTracks().length === 0) {
                showPlaceholder("No se detectó video. Asegúrate de que OBS esté abierto y la cámara virtual activada.");
                alert("No se detectó video. Asegúrate de que OBS esté abierto, la cámara virtual esté activada (Tools > VirtualCam > Start), y selecciona 'OBS-Camera'.");
                isStreaming = false;
                startButton.disabled = false;
                startButton.textContent = "INICIAR TRANSMISIÓN";
                return;
            }

            // Asignar el stream al elemento de video para vista previa del streamer
            liveStreamVideo.srcObject = localStream;
            liveStreamVideo.muted = true;
            showStream();
            isStreaming = true;

            // Notificar al servidor que el stream ha comenzado
            ws.send(JSON.stringify({ type: 'start_stream', from_id: currentUsername }));

            // Rehabilitar el botón después de 5 segundos
            setTimeout(() => {
                if (isStreaming) {
                    startButton.disabled = false;
                    startButton.textContent = "CAMBIAR FUENTE";
                }
            }, 5000);

            // Listener para cuando el streamer detiene la compartición
            localStream.getVideoTracks()[0].onended = () => {
                console.log("Stream detenido por el usuario");
                ws.send(JSON.stringify({ type: 'stream_ended', from_id: currentUsername }));
                isStreaming = false;
                startButton.disabled = false;
                startButton.textContent = "INICIAR TRANSMISIÓN";
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                Object.values(peerConnections).forEach(pc => pc.close());
                peerConnections = {};
                showPlaceholder("Transmisión finalizada.");
            };
        } catch (err) {
            console.error("Error al capturar la cámara virtual de OBS:", err);
            showPlaceholder("Error al capturar la cámara virtual. Verifica OBS y selecciona 'OBS-Camera'.");
            alert("Error al capturar la cámara virtual. Asegúrate de que OBS esté abierto, la cámara virtual esté activada, y selecciona 'OBS-Camera'.");
            isStreaming = false;
            startButton.disabled = false;
            startButton.textContent = "INICIAR TRANSMISIÓN";
        }
    };

    // LÓGICA DE WEBSOCKET
    function connectWebSocket(username) {
        console.log("Intentando conectar WebSocket...");
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsHost = window.location.host;
        ws = new WebSocket(`${wsProtocol}//${wsHost}/ws/users`);

        let heartbeatInterval;

        ws.onopen = () => {
            console.log("Conectado al servidor. WebSocket está OPEN.");
            ws.send(JSON.stringify({ type: "login", name: username }));

            heartbeatInterval = setInterval(() => {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'ping' }));
                }
            }, 25000);
        };

        ws.onmessage = async (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'pong') return;
                console.log("Mensaje recibido:", data);

                switch (data.type) {
                    case 'login_success':
                        userRole = data.role;
                        streamerId = data.streamer_id || ''; // Obtener el ID del streamer
                        console.log(`Rol asignado: ${userRole}, Streamer ID: ${streamerId}`);
                        loginContainer.style.display = 'none';
                        welcomeContainer.style.display = 'block';
                        welcomeMessage.textContent = `¡Bienvenido, ${currentUsername}!`;
                        break;

                    case 'stream_started':
                        isStreaming = true;
                        console.log("Stream iniciado. Estado isStreaming:", isStreaming);
                        if (mainContainer.style.display === 'block' && userRole === 'viewer') {
                            showStream();
                            startViewing();
                        }
                        break;
                    
                    case 'stream_ended':
                        isStreaming = false;
                        console.log("Stream finalizado. Estado isStreaming:", isStreaming);
                        showPlaceholder("La transmisión ha finalizado.");
                        if (userRole === 'streamer') {
                            startButton.disabled = false;
                            startButton.textContent = "INICIAR TRANSMISIÓN";
                            if (localStream) localStream.getTracks().forEach(track => track.stop());
                            localStream = null;
                            Object.values(peerConnections).forEach(pc => pc.close());
                            peerConnections = {};
                        } else {
                            if (peerConnection) peerConnection.close();
                            peerConnection = null;
                            liveStreamVideo.srcObject = null;
                        }
                        break;

                    case 'offer':
                        if (userRole === 'streamer') {
                            console.log(`Oferta recibida de ${data.from_id}`);
                            await handleOffer(data.offer, data.from_id);
                        }
                        break;
                    case 'answer':
                        if (userRole === 'viewer') {
                            console.log(`Respuesta recibida de streamer`);
                            await handleAnswer(data.answer, data.from_id);
                        }
                        break;
                    case 'candidate':
                        console.log(`Candidato ICE recibido de ${data.from_id} para ${data.target_id}`);
                        await handleCandidate(data.candidate, data.from_id);
                        break;
                }
            } catch (e) {
                console.log("Mensaje de texto plano recibido:", event.data);
            }
        };

        ws.onclose = (event) => {
            console.log("Conexión cerrada.", event.code, event.reason);
            clearInterval(heartbeatInterval);
            ws = null;
            loginContainer.style.display = 'block';
            mainContainer.style.display = 'none';
            welcomeContainer.style.display = 'none';
            alert("Se ha perdido la conexión con el servidor. Por favor, ingresa de nuevo.");
        };

        ws.onerror = (error) => {
            console.error("Error en WebSocket:", error);
        };
    }

    // LÓGICA DE WEBRTC
    async function startViewing() {
        if (!streamerId) {
            console.error("No se ha recibido el ID del streamer. No se puede iniciar la visualización.");
            showPlaceholder("No hay streamer disponible.");
            return;
        }
        console.log("Iniciando conexión WebRTC como espectador...");
        peerConnection = new RTCPeerConnection(configuration);

        pendingCandidates['viewer'] = [];

        peerConnection.ontrack = (event) => {
            console.log("-> EVENTO ONTRACK DISPARADO");
            const remoteStream = event.streams[0];
            console.log("Pistas de video:", remoteStream.getVideoTracks());
            console.log("Pistas de audio:", remoteStream.getAudioTracks());

            if (liveStreamVideo.srcObject !== remoteStream) {
                console.log("Asignando nuevo stream al elemento de video.");
                liveStreamVideo.srcObject = remoteStream;
            }

            liveStreamVideo.muted = true;
            liveStreamVideo.playsInline = true;

            console.log("Intentando reproducir el video...");
            const playPromise = liveStreamVideo.play();

            if (playPromise !== undefined) {
                playPromise.then(() => {
                    console.log("¡La reproducción del video se inició con éxito!");
                    showStream();
                }).catch(error => {
                    console.error("La reproducción automática fue bloqueada:", error);
                    showPlaceholder("Transmisión lista. Haz clic aquí para reproducir.");

                    const playOnClick = () => {
                        console.log("Intentando reproducir por clic del usuario...");
                        liveStreamVideo.play().then(() => {
                            console.log("¡Reproducción iniciada por el usuario!");
                            showStream();
                            liveStreamVideo.removeEventListener('click', playOnClick);
                        }).catch(err => {
                            console.error("La reproducción por clic también falló:", err);
                        });
                    };
                    liveStreamVideo.addEventListener('click', playOnClick);
                });
            }
        };

        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log('Enviando candidato ICE:', event.candidate);
                ws.send(JSON.stringify({ 
                    type: 'candidate', 
                    candidate: event.candidate,
                    target_id: streamerId,
                    from_id: currentUsername
                }));
            }
        };

        peerConnection.onconnectionstatechange = () => {
            console.log("Estado de conexión WebRTC:", peerConnection.connectionState);
        };

        try {
            peerConnection.addTransceiver('video', {'direction': 'recvonly'});
            peerConnection.addTransceiver('audio', {'direction': 'recvonly'});
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            console.log("Oferta enviada:", peerConnection.localDescription);
            ws.send(JSON.stringify({ 
                type: 'offer', 
                offer: peerConnection.localDescription, 
                from_id: currentUsername, 
                target_id: streamerId 
            }));
            if (pendingCandidates['viewer'].length > 0) {
                console.log("Procesando candidatos pendientes para viewer...");
                for (const candidate of pendingCandidates['viewer']) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log("Candidato ICE añadido para viewer");
                }
                pendingCandidates['viewer'] = [];
            }
        } catch (error) {
            console.error("Error al crear o enviar la oferta:", error);
        }
    }

    async function handleOffer(offer, viewerId) {
        console.log(`Manejando oferta de ${viewerId}`);
        const pc = new RTCPeerConnection(configuration);
        peerConnections[viewerId] = pc;

        pendingCandidates[viewerId] = [];

        pc.onicecandidate = event => {
            if (event.candidate) {
                console.log(`Enviando candidato ICE para ${viewerId}:`, event.candidate);
                ws.send(JSON.stringify({ 
                    type: 'candidate', 
                    candidate: event.candidate,
                    target_id: viewerId,
                    from_id: currentUsername
                }));
            }
        };

        pc.onconnectionstatechange = () => {
            console.log(`Estado de conexión WebRTC para ${viewerId}:`, pc.connectionState);
        };

        try {
            await pc.setRemoteDescription(new RTCSessionDescription(offer));
            console.log(`remoteDescription configurada para ${viewerId}`);
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                    console.log(`Pista añadida para ${viewerId}: ${track.kind} (id: ${track.id})`);
                });
            } else {
                console.warn(`No hay localStream disponible para ${viewerId}`);
            }
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            console.log(`Respuesta enviada para ${viewerId}:`, answer);
            ws.send(JSON.stringify({ 
                type: 'answer', 
                answer: answer,
                target_id: viewerId,
                from_id: currentUsername
            }));
            if (pendingCandidates[viewerId].length > 0) {
                console.log(`Procesando candidatos pendientes para ${viewerId}...`);
                for (const candidate of pendingCandidates[viewerId]) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log(`Candidato ICE añadido para ${viewerId}`);
                }
                pendingCandidates[viewerId] = [];
            }
        } catch (error) {
            console.error(`Error manejando oferta de ${viewerId}:`, error);
        }
    }

    async function handleAnswer(answer, fromId) {
        const pc = peerConnection; // Viewer usa una sola peerConnection
        if (pc) {
            try {
                await pc.setRemoteDescription(new RTCSessionDescription(answer));
                console.log(`remoteDescription configurada para respuesta de ${fromId}`);
                if (pendingCandidates['viewer'].length > 0) {
                    console.log(`Procesando candidatos pendientes para viewer...`);
                    for (const candidate of pendingCandidates['viewer']) {
                        await pc.addIceCandidate(new RTCIceCandidate(candidate));
                        console.log(`Candidato ICE añadido para viewer`);
                    }
                    pendingCandidates['viewer'] = [];
                }
            } catch (error) {
                console.error(`Error manejando respuesta de ${fromId}:`, error);
            }
        } else {
            console.warn(`No se encontró peerConnection para el viewer`);
        }
    }

    async function handleCandidate(candidate, fromId) {
        const pc = (userRole === 'streamer') ? peerConnections[fromId] : peerConnection;
        if (pc) {
            try {
                if (pc.remoteDescription && pc.remoteDescription.type) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log(`Candidato ICE añadido para ${fromId}`);
                } else {
                    console.log(`remoteDescription no está lista para ${fromId}. Almacenando candidato...`);
                    if (!pendingCandidates[fromId] && userRole === 'streamer') {
                        pendingCandidates[fromId] = [];
                    } else if (!pendingCandidates['viewer'] && userRole === 'viewer') {
                        pendingCandidates['viewer'] = [];
                    }
                    (userRole === 'streamer' ? pendingCandidates[fromId] : pendingCandidates['viewer']).push(candidate);
                }
            } catch (e) {
                console.error(`Error añadiendo candidato ICE para ${fromId}:`, e);
            }
        } else {
            console.warn(`No se encontró peerConnection para ${fromId}`);
        }
    }

    // Funciones de UI
    function showStream() {
        liveStreamVideo.style.visibility = 'visible';
        streamPlaceholder.style.display = 'none';
    }

    function showPlaceholder(message) {
        liveStreamVideo.style.visibility = 'hidden';
        streamPlaceholder.textContent = message;
        streamPlaceholder.style.display = 'block';
    }
</script>
</body>
</html>
-->

<!--
<!DOCTYPE html>
<html>
<head>
    <title>Ruleta Americana - WebRTC P2P</title>
    <style>
        body { 
            font-family: sans-serif; 
            margin: 0; /* Eliminar márgenes para consistencia */
            padding: 0; /* Eliminar padding para consistencia */
        }
        #main-container, #capture-controls { display: none; }
        #login-container { text-align: center; margin-top: 50px; }
        .video-container {
            width: 50%; /* Ancho inicial del 50% */
            background-color: #000;
            position: relative;
            box-sizing: border-box; /* Asegura que el tamaño incluya bordes y padding */
        }
        #live-stream {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain; /* Preserva la relación de aspecto sin recorte */
            image-rendering: pixelated; /* Evita escalado suave del navegador */
        }
        .video-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
            font-size: 1.5em;
            text-align: center;
        }
        #welcome-container {
            display: none;
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        #enter-game-button {
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        #enter-game-button:hover {
            background-color: #0056b3;
        }
        #tutorial-video {
            width: 50%;
            height: auto;
        }
    </style>
</head>
<body>
    <div id="login-container">
        <h1>Bienvenido a la Ruleta Americana</h1>
        <p>Por favor, ingresa tu nombre para continuar.</p>
        <form id="login-form">
			<input type="text" id="name-input" placeholder="Tu nombre" required>
			<button type="submit">Ingresar</button>
		</form>
    </div>
    <div id="welcome-container">
        <h1 id="welcome-message"></h1>
        <p>¡Todo listo para empezar!</p>
        <video id="tutorial-video" src="/static/color_wheel.mp4" controls></video>
        <button id="enter-game-button">ENTRAR AL JUEGO</button>
    </div>
    <div id="main-container">
        <h1>Ruleta Americana (Stream en Vivo - WebRTC)</h1>
        <div class="video-container">
            <video id="live-stream" autoplay muted playsinline></video>
            <div id="streamPlaceholder" class="video-placeholder">Esperando transmisión...</div>
        </div>
        <div id="capture-controls">
            <button id="startButton">INICIAR TRANSMISIÓN</button>
        </div>
        <br>
        <p id="fecha_hora">Fecha y Hora: Esperando...</p>
        <p id="juego_numero">Juego Número: Esperando...</p>
        <p id="usuarios">Usuarios conectados: 0</p>
        <h1>Realiza tu apuesta</h1>
        <form onsubmit="sendMessage(event)">
            <label>Jugador: <strong id="nombre-logueado"></strong></label>
            <br><br>
            <input type="number" id="apuesta" placeholder="Número de apuesta" autocomplete="off" min="0" max="36" required/>
            <button id="btnEnviarApuesta" disabled>Enviar</button>
        </form>
        <ul id="messages"></ul>
    </div>

<script>
    // Referencias al DOM
    const loginContainer = document.getElementById('login-container');
    const mainContainer = document.getElementById('main-container');
    const loginForm = document.getElementById('login-form');
    const nameInput = document.getElementById('name-input');
    const startButton = document.getElementById('startButton');
    const captureControls = document.getElementById('capture-controls');
    const liveStreamVideo = document.getElementById('live-stream');
    const streamPlaceholder = document.getElementById('streamPlaceholder');
	
	const fechaHoraElem = document.getElementById('fecha_hora');
	const juegoNumeroElem = document.getElementById('juego_numero');
    const usuariosElem = document.getElementById('usuarios');
    const messagesElem = document.getElementById('messages');
	
	const nombreLogueadoElem = document.getElementById('nombre-logueado');
    const btnEnviarApuesta = document.getElementById('btnEnviarApuesta');
	
    const welcomeContainer = document.getElementById('welcome-container');
    const welcomeMessage = document.getElementById('welcome-message');
    const enterGameButton = document.getElementById('enter-game-button');
    const videoContainer = document.querySelector('.video-container');
    
    // Estado Global y Configuración
    let ws = null;
    let userRole = "viewer";
    let isStreaming = false;
    let localStream;
    let peerConnections = {};
    let peerConnection;
    let currentUsername = '';
    let streamerId = '';
    const pendingCandidates = {};
	let intervalId = null;
    let currentDateTime = null;
		
    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            {
                urls: 'turn:relay1.expressturn.com:3480',
                username: '000000002067441357',
                credential: 'ZWtqCZGCwebs2UeE8c8ryeqBHN8='
            }
        ]
    };
	
	// Función para actualizar la fecha y hora cada segundo
	function startDateTimeUpdate(fechaHoraStr) {
		// Detener cualquier intervalo existente
		if (intervalId) {
			clearInterval(intervalId);
		}

		// Parsear la fecha y hora recibida (formato: "DD-MM-YYYY HH:MM:SS")
		const [datePart, timePart] = fechaHoraStr.split(' ');
		const [day, month, year] = datePart.split('-').map(Number);
		const [hours, minutes, seconds] = timePart.split(':').map(Number);
		currentDateTime = new Date(year, month - 1, day, hours, minutes, seconds);

		// Actualizar el elemento HTML cada segundo
		intervalId = setInterval(() => {
			currentDateTime.setSeconds(currentDateTime.getSeconds() + 1);
			const formattedDateTime = `Fecha: ${currentDateTime.getDate().toString().padStart(2, '0')}/${(currentDateTime.getMonth() + 1).toString().padStart(2, '0')}/${currentDateTime.getFullYear()}\nHora: ${currentDateTime.getHours().toString().padStart(2, '0')}:${currentDateTime.getMinutes().toString().padStart(2, '0')}:${currentDateTime.getSeconds().toString().padStart(2, '0')}`;
			document.getElementById('fecha_hora').textContent = formattedDateTime;
		}, 1000);
	}
		
    // INICIO DEL FLUJO DE LA APLICACIÓN
    loginForm.onsubmit = (event) => {
        event.preventDefault();
        const username = nameInput.value.trim();
        if (username) {
            if (!ws || ws.readyState === WebSocket.CLOSED) {
                currentUsername = username;
                connectWebSocket(username);
            } else {
                console.log("Ya se está intentando una conexión.");
            }
        } else {
            alert("Por favor, ingresa un nombre.");
        }
    };

    enterGameButton.onclick = () => {
        console.log("Usuario ha entrado al juego. Mostrando contenedor principal.");
        welcomeContainer.style.display = 'none';
        mainContainer.style.display = 'block';

        if (userRole === 'streamer') {
            captureControls.style.display = 'block';
        }
        
        if (userRole === 'viewer' && isStreaming) {
            console.log("Stream ya está activo. Iniciando visualización...");
            startViewing();
        }
    };

    startButton.onclick = async () => {
        // Deshabilitar el botón temporalmente para evitar clics rápidos
        startButton.disabled = true;
        startButton.textContent = "CARGANDO...";

        try {
            // Liberar el stream anterior y conexiones WebRTC
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                console.log("Stream anterior liberado.");
            }
            Object.values(peerConnections).forEach(pc => pc.close());
            peerConnections = {};

            // Mostrar mensaje para guiar al usuario
            showPlaceholder("Selecciona 'OBS-Camera' o 'OBS Virtual Camera' en el diálogo.");

            // Capturar la cámara virtual de OBS
            localStream = await navigator.mediaDevices.getUserMedia({
                video: true,
                audio: true // Capturar audio si está configurado en OBS
            });
            console.log("Pistas capturadas:", localStream.getVideoTracks(), localStream.getAudioTracks());

            // Verificar si se capturó video
            if (localStream.getVideoTracks().length === 0) {
                showPlaceholder("No se detectó video. Verifica OBS.");
                alert("No se detectó video. Asegúrate de que OBS esté abierto, la cámara virtual esté activada (Tools > VirtualCam > Start), y selecciona 'OBS-Camera'.");
                isStreaming = false;
                startButton.disabled = false;
                startButton.textContent = "INICIAR TRANSMISIÓN";
                return;
            }

            // Asignar el stream al elemento de video para vista previa
            liveStreamVideo.srcObject = localStream;
            liveStreamVideo.muted = true;
            showStream();

            // Ajustar el ancho y la relación de aspecto del contenedor para el streamer
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                const settings = videoTrack.getSettings();
                const width = settings.width;
                const height = settings.height;
                const aspectRatio = width / height;
                console.log(`[Streamer] Resolución capturada: ${width}x${height}, Aspect Ratio: ${aspectRatio}`);
                videoContainer.style.width = `${width}px`; // Ajustar al ancho exacto del stream
                videoContainer.style.aspectRatio = aspectRatio; // Mantener la relación de aspecto
            }

            // Notificar al servidor que el stream ha comenzado
            ws.send(JSON.stringify({ type: 'start_stream', from_id: currentUsername }));

            // Rehabilitar el botón después de 5 segundos
            setTimeout(() => {
                if (isStreaming) {
                    startButton.disabled = false;
                    startButton.textContent = "CAMBIAR FUENTE";
                }
            }, 5000);

            // Listener para cuando el streamer detiene la compartición
            localStream.getVideoTracks()[0].onended = () => {
                console.log("Stream detenido por el usuario");
                ws.send(JSON.stringify({ type: 'stream_ended', from_id: currentUsername }));
                isStreaming = false;
                startButton.disabled = false;
                startButton.textContent = "INICIAR TRANSMISIÓN";
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                Object.values(peerConnections).forEach(pc => pc.close());
                peerConnections = {};
                showPlaceholder("Transmisión finalizada.");
            };
        } catch (err) {
            console.error("Error al capturar la cámara virtual de OBS:", err);
            showPlaceholder("Error al capturar la cámara virtual. Verifica OBS.");
            alert("Error al capturar la cámara virtual. Asegúrate de que OBS esté abierto, la cámara virtual esté activada, y selecciona 'OBS-Camera'.");
            isStreaming = false;
            startButton.disabled = false;
            startButton.textContent = "INICIAR TRANSMISIÓN";
        }
    };

    // LÓGICA DE WEBSOCKET
    function connectWebSocket(username) {
        console.log("Intentando conectar WebSocket...");
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsHost = window.location.host;
        ws = new WebSocket(`${wsProtocol}//${wsHost}/ws/users`);

        let heartbeatInterval;
        let retryCount = 0;
        const maxRetries = 5;

        ws.onopen = () => {
            console.log("Conectado al servidor. WebSocket está en estado OPEN.");
            ws.send(JSON.stringify({ type: "login", name: username }));
            retryCount = 0;

            heartbeatInterval = setInterval(() => {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'ping' }));
                }
            }, 25000);
        };

        ws.onmessage = async (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'pong') return;
                console.log("Mensaje recibido:", data);

                switch (data.type) {
                    case 'login_success':
                        userRole = data.role;
                        streamerId = data.streamer_id || '';
                        console.log(`Rol asignado: ${userRole}, Streamer ID: ${streamerId}`);
                        if (!streamerId && userRole === 'viewer') {
                            console.warn("No se recibió streamer_id. No se puede iniciar visualización.");
                            showPlaceholder("No hay streamer disponible.");
                        }
                        loginContainer.style.display = 'none';
                        welcomeContainer.style.display = 'block';
                        welcomeMessage.textContent = `¡Bienvenido, ${currentUsername}!`;
                        break;

                    case 'stream_started':
                        isStreaming = true;
                        console.log("Stream iniciado. Estado isStreaming:", isStreaming);
                        if (mainContainer.style.display === 'block' && userRole === 'viewer') {
                            showStream();
                            startViewing();
                        }
                        break;
                    
                    case 'stream_ended':
                        isStreaming = false;
                        console.log("Stream finalizado. Estado isStreaming:", isStreaming);
                        showPlaceholder("La transmisión ha finalizado.");
                        if (userRole === 'streamer') {
                            startButton.disabled = false;
                            startButton.textContent = "INICIAR TRANSMISIÓN";
                            if (localStream) localStream.getTracks().forEach(track => track.stop());
                            localStream = null;
                            Object.values(peerConnections).forEach(pc => pc.close());
                            peerConnections = {};
                        } else {
                            if (peerConnection) peerConnection.close();
                            peerConnection = null;
                            liveStreamVideo.srcObject = null;
                        }
                        break;

                    case 'offer':
                        if (userRole === 'streamer') {
                            console.log(`Oferta recibida de ${data.from_id}`);
                            await handleOffer(data.offer, data.from_id);
                        }
                        break;
                    case 'answer':
                        if (userRole === 'viewer') {
                            console.log(`Respuesta recibida de streamer`);
                            await handleAnswer(data.answer, data.from_id);
                        }
                        break;
                    case 'candidate':
                        console.log(`Candidato ICE recibido de ${data.from_id} para ${data.target_id}`);
                        await handleCandidate(data.candidate, data.from_id);
                        break;
					case 'fecha_hora':
                        fechaHoraElem.textContent = 'Fecha y Hora: ' + data.payload;
						startDateTimeUpdate(data.payload);
                        break;
                    default:
                        console.log("Mensaje JSON desconocido:", data);
                }
            } catch (e) {
                console.log("Mensaje de texto plano recibido:", event.data);
				// El mensaje no es JSON, lo tratamos como texto plano
                const messageText = event.data;
                
                // CAMBIO 7: Lógica para habilitar/deshabilitar el botón de apuesta
                if (messageText.trim() === "INICIO del juego") {
                    btnEnviarApuesta.disabled = false;
                    console.log("Apuestas habilitadas.");
                } else if (messageText.trim() === "FIN del juego") {
                    btnEnviarApuesta.disabled = true;
                    console.log("Apuestas deshabilitadas.");
                }
                
                // Mantenemos la lógica existente para otros mensajes de texto
                if (messageText.startsWith("Usuarios conectados:")) {
                    usuariosElem.textContent = messageText;
                } else {
                    const li = document.createElement('li');
                    li.textContent = messageText;
                    messagesElem.appendChild(li);
                }
            }
        };

        ws.onclose = (event) => {
            console.log("Conexión cerrada.", event.code, event.reason);
			//console.log("Desconectado del servidor.");
			// Detener la actualización si el WebSocket se cierra
			if (intervalId) {
				clearInterval(intervalId);
				intervalId = null;
			}
			document.getElementById('fecha_hora').textContent = 'Fecha y Hora: Desconectado';
			
            clearInterval(heartbeatInterval);
            ws = null;
            if (retryCount < maxRetries) {
                retryCount++;
                console.log(`Reintentando conexión (${retryCount}/${maxRetries})...`);
                setTimeout(() => connectWebSocket(username), 3000 * retryCount);
            } else {
                loginContainer.style.display = 'block';
                mainContainer.style.display = 'none';
                welcomeContainer.style.display = 'none';
                alert("Se ha perdido la conexión con el servidor. Por favor, recarga la página.");
            }
        };

        ws.onerror = (error) => {
            console.error("Error en WebSocket:", error);
        };
    }

    // LÓGICA DE WEBRTC
    async function startViewing() {
        if (!streamerId) {
            console.error("No se ha recibido el ID del streamer.");
            showPlaceholder("No hay streamer disponible.");
            return;
        }
        try {
            console.log("Iniciando conexión WebRTC como espectador...");
            peerConnection = new RTCPeerConnection(configuration);

            pendingCandidates['viewer'] = [];

            peerConnection.ontrack = (event) => {
                console.log("-> EVENTO ONTRACK DISPARADO");
                const remoteStream = event.streams[0];
                console.log("Pistas de video:", remoteStream.getVideoTracks());
                console.log("Pistas de audio:", remoteStream.getAudioTracks());

                if (liveStreamVideo.srcObject !== remoteStream) {
                    console.log("Asignando nuevo stream al elemento de video.");
                    liveStreamVideo.srcObject = remoteStream;
                }

                liveStreamVideo.muted = true;
                liveStreamVideo.playsInline = true;

                // Ajustar el ancho y la relación de aspecto del contenedor para el espectador
                const videoTrack = remoteStream.getVideoTracks()[0];
                if (videoTrack) {
                    const settings = videoTrack.getSettings();
                    const width = settings.width;
                    const height = settings.height;
                    const aspectRatio = width / height;
                    console.log(`[Viewer] Resolución recibida: ${width}x${height}, Aspect Ratio: ${aspectRatio}`);
                    videoContainer.style.width = `${width}px`; // Ajustar al ancho exacto del stream
                    videoContainer.style.aspectRatio = aspectRatio; // Mantener la relación de aspecto
                }

                console.log("Intentando reproducir el video...");
                const playVideo = () => {
                    liveStreamVideo.play().then(() => {
                        console.log("¡Reproducción iniciada!");
                        showStream();
                    }).catch(error => {
                        console.error("Error al reproducir video:", error);
                        showPlaceholder("Haz clic para reproducir la transmisión.");
                        liveStreamVideo.addEventListener('click', playVideo, { once: true });
                    });
                };
                playVideo();
            };

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Enviando candidato ICE:', event.candidate);
                    ws.send(JSON.stringify({ 
                        type: 'candidate', 
                        candidate: event.candidate,
                        target_id: streamerId,
                        from_id: currentUsername
                    }));
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                console.log("Estado de conexión ICE:", peerConnection.iceConnectionState);
                if (peerConnection.iceConnectionState === 'failed') {
                    console.error("Fallo en la conexión ICE. Verifica el servidor TURN.");
                    showPlaceholder("Error de conexión. Intenta de nuevo.");
                }
            };

            peerConnection.addTransceiver('video', {'direction': 'recvonly'});
            peerConnection.addTransceiver('audio', {'direction': 'recvonly'});
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            console.log("Oferta enviada:", peerConnection.localDescription);
            ws.send(JSON.stringify({ 
                type: 'offer', 
                offer: peerConnection.localDescription, 
                from_id: currentUsername, 
                target_id: streamerId 
            }));
            if (pendingCandidates['viewer'].length > 0) {
                console.log("Procesando candidatos pendientes para viewer...");
                for (const candidate of pendingCandidates['viewer']) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log("Candidato ICE añadido para viewer");
                }
                pendingCandidates['viewer'] = [];
            }
        } catch (error) {
            console.error("Error en startViewing:", error);
            showPlaceholder("Error al conectar con el streamer.");
        }
    }

    async function handleOffer(offer, viewerId) {
        console.log(`Manejando oferta de ${viewerId}`);
        const pc = new RTCPeerConnection(configuration);
        peerConnections[viewerId] = pc;

        pendingCandidates[viewerId] = [];

        pc.onicecandidate = event => {
            if (event.candidate) {
                console.log(`Enviando candidato ICE para ${viewerId}:`, event.candidate);
                ws.send(JSON.stringify({ 
                    type: 'candidate', 
                    candidate: event.candidate,
                    target_id: viewerId,
                    from_id: currentUsername
                }));
            }
        };

        pc.onconnectionstatechange = () => {
            console.log(`Estado de conexión WebRTC para ${viewerId}:`, pc.connectionState);
        };

        try {
            await pc.setRemoteDescription(new RTCSessionDescription(offer));
            console.log(`remoteDescription configurada para ${viewerId}`);
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                    console.log(`Pista añadida para ${viewerId}: ${track.kind} (id: ${track.id})`);
                });
            } else {
                console.error("No hay localStream disponible.");
                return;
            }
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            console.log(`Respuesta enviada para ${viewerId}:`, answer);
            ws.send(JSON.stringify({ 
                type: 'answer', 
                answer: answer,
                target_id: viewerId,
                from_id: currentUsername
            }));
            if (pendingCandidates[viewerId].length > 0) {
                console.log(`Procesando candidatos pendientes para ${viewerId}...`);
                for (const candidate of pendingCandidates[viewerId]) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log(`Candidato ICE añadido para ${viewerId}`);
                }
                pendingCandidates[viewerId] = [];
            }
        } catch (error) {
            console.error(`Error manejando oferta de ${viewerId}:`, error);
        }
    }

    async function handleAnswer(answer, fromId) {
        const pc = peerConnection;
        if (pc) {
            try {
                await pc.setRemoteDescription(new RTCSessionDescription(answer));
                console.log(`remoteDescription configurada para respuesta de ${fromId}`);
                if (pendingCandidates['viewer'].length > 0) {
                    console.log(`Procesando candidatos pendientes para viewer...`);
                    for (const candidate of pendingCandidates['viewer']) {
                        await pc.addIceCandidate(new RTCIceCandidate(candidate));
                        console.log(`Candidato ICE añadido para viewer`);
                    }
                    pendingCandidates['viewer'] = [];
                }
            } catch (error) {
                console.error(`Error manejando respuesta de ${fromId}:`, error);
            }
        } else {
            console.warn(`No se encontró peerConnection para el viewer`);
        }
    }

    async function handleCandidate(candidate, fromId) {
        const pc = (userRole === 'streamer') ? peerConnections[fromId] : peerConnection;
        if (pc) {
            try {
                if (pc.remoteDescription && pc.remoteDescription.type) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log(`Candidato ICE añadido para ${fromId}`);
                } else {
                    console.log(`remoteDescription no está lista para ${fromId}. Almacenando candidato...`);
                    if (!pendingCandidates[fromId] && userRole === 'streamer') {
                        pendingCandidates[fromId] = [];
                    } else if (!pendingCandidates['viewer'] && userRole === 'viewer') {
                        pendingCandidates['viewer'] = [];
                    }
                    (userRole === 'streamer' ? pendingCandidates[fromId] : pendingCandidates['viewer']).push(candidate);
                }
            } catch (e) {
                console.error(`Error añadiendo candidato ICE para ${fromId}:`, e);
            }
        } else {
            console.warn(`No se encontró peerConnection para ${fromId}`);
        }
    }

    // Funciones de UI
    function showStream() {
        liveStreamVideo.style.visibility = 'visible';
        streamPlaceholder.style.display = 'none';
    }

    function showPlaceholder(message) {
        liveStreamVideo.style.visibility = 'hidden';
        streamPlaceholder.textContent = message;
        streamPlaceholder.style.display = 'block';
    }
</script>
</body>
</html>
-->

<!-- index.html 
<!DOCTYPE html>
<html>
<head>
    <title>Ruleta Americana - WebRTC P2P</title>
    <style>
        body { 
            font-family: sans-serif; 
            margin: 0; /* Eliminar márgenes para consistencia */
            padding: 0; /* Eliminar padding para consistencia */
        }
        #main-container, #capture-controls { display: none; }
        #login-container { text-align: center; margin-top: 50px; }
        .video-container {
            width: 50%; /* Ancho inicial del 50% */
            background-color: #000;
            position: relative;
            box-sizing: border-box; /* Asegura que el tamaño incluya bordes y padding */
        }
        #live-stream {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain; /* Preserva la relación de aspecto sin recorte */
            image-rendering: pixelated; /* Evita escalado suave del navegador */
        }
        .video-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
            font-size: 1.5em;
            text-align: center;
        }
        #welcome-container {
            display: none;
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        #enter-game-button {
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        #enter-game-button:hover {
            background-color: #0056b3;
        }
        #tutorial-video {
            width: 50%;
            height: auto;
        }
    </style>
</head>
<body>
    <div id="login-container">
        <h1>Bienvenido a la Ruleta Americana</h1>
        <p>Por favor, ingresa tu nombre para continuar.</p>
        <form id="login-form">
            <input type="text" id="name-input" placeholder="Tu nombre" required>
            <button type="submit">Ingresar</button>
        </form>
    </div>
    <div id="welcome-container">
        <h1 id="welcome-message"></h1>
        <p>¡Todo listo para empezar!</p>
        <video id="tutorial-video" src="/static/color_wheel.mp4" controls></video>
        <button id="enter-game-button">ENTRAR AL JUEGO</button>
    </div>
    <div id="main-container">
        <h1>Ruleta Americana (Stream en Vivo - WebRTC)</h1>
        <div class="video-container">
            <video id="live-stream" autoplay muted playsinline></video>
            <div id="streamPlaceholder" class="video-placeholder">Esperando transmisión...</div>
        </div>
        <div id="capture-controls">
            <button id="startButton">INICIAR TRANSMISIÓN</button>
        </div>
        <br>
        <p id="fecha_hora">Fecha y Hora: Esperando...</p>
        <p id="juego_numero">Juego Número: Esperando...</p>
        <p id="usuarios">Usuarios conectados: 0</p>
        <h1>Realiza tu apuesta</h1>
        <form onsubmit="sendMessage(event)">
            <label>Jugador: <strong id="nombre-logueado"></strong></label>
            <br><br>
            <input type="number" id="apuesta" placeholder="Número de apuesta" autocomplete="off" min="0" max="36" required/>
            <button id="btnEnviarApuesta" disabled>Enviar</button>
        </form>
        <ul id="messages"></ul>
    </div>

<script>
    // Referencias al DOM
    const loginContainer = document.getElementById('login-container');
    const mainContainer = document.getElementById('main-container');
    const loginForm = document.getElementById('login-form');
    const nameInput = document.getElementById('name-input');
    const startButton = document.getElementById('startButton');
    const captureControls = document.getElementById('capture-controls');
    const liveStreamVideo = document.getElementById('live-stream');
    const streamPlaceholder = document.getElementById('streamPlaceholder');
    
    const fechaHoraElem = document.getElementById('fecha_hora');
    const juegoNumeroElem = document.getElementById('juego_numero');
    const usuariosElem = document.getElementById('usuarios');
    const messagesElem = document.getElementById('messages');
    
    const nombreLogueadoElem = document.getElementById('nombre-logueado');
    const btnEnviarApuesta = document.getElementById('btnEnviarApuesta');
    
    const welcomeContainer = document.getElementById('welcome-container');
    const welcomeMessage = document.getElementById('welcome-message');
    const enterGameButton = document.getElementById('enter-game-button');
    const videoContainer = document.querySelector('.video-container');
    
    // Estado Global y Configuración
    let ws = null;
    let userRole = "viewer";
    let isStreaming = false;
    let localStream;
    let peerConnections = {};
    let peerConnection;
    let currentUsername = '';
    let streamerId = '';
    const pendingCandidates = {};
    let intervalId = null;
    let currentDateTime = null;
        
    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            {
                urls: 'turn:relay1.expressturn.com:3480',
                username: '000000002067441357',
                credential: 'ZWtqCZGCwebs2UeE8c8ryeqBHN8='
            }
        ]
    };
    
    // Función para actualizar la fecha y hora cada segundo
    function startDateTimeUpdate(fechaHoraStr) {
        // Detener cualquier intervalo existente
        if (intervalId) {
            clearInterval(intervalId);
        }

        // Parsear la fecha y hora recibida (formato: "DD-MM-YYYY HH:MM:SS")
        const [datePart, timePart] = fechaHoraStr.split(' ');
        const [day, month, year] = datePart.split('-').map(Number);
        const [hours, minutes, seconds] = timePart.split(':').map(Number);
        currentDateTime = new Date(year, month - 1, day, hours, minutes, seconds);

        // Actualizar el elemento HTML cada segundo
        intervalId = setInterval(() => {
            currentDateTime.setSeconds(currentDateTime.getSeconds() + 1);
            const formattedDateTime = `Fecha: ${currentDateTime.getDate().toString().padStart(2, '0')}/${(currentDateTime.getMonth() + 1).toString().padStart(2, '0')}/${currentDateTime.getFullYear()}\nHora: ${currentDateTime.getHours().toString().padStart(2, '0')}:${currentDateTime.getMinutes().toString().padStart(2, '0')}:${currentDateTime.getSeconds().toString().padStart(2, '0')}`;
            document.getElementById('fecha_hora').textContent = formattedDateTime;
        }, 1000);
    }
        
    // INICIO DEL FLUJO DE LA APLICACIÓN
    loginForm.onsubmit = (event) => {
        event.preventDefault();
        const username = nameInput.value.trim();
        if (username) {
            if (!ws || ws.readyState === WebSocket.CLOSED) {
                currentUsername = username;
                connectWebSocket(username);
            } else {
                console.log("Ya se está intentando una conexión.");
            }
        } else {
            alert("Por favor, ingresa un nombre.");
        }
    };

    enterGameButton.onclick = () => {
        console.log("Usuario ha entrado al juego. Mostrando contenedor principal.");
        welcomeContainer.style.display = 'none';
        mainContainer.style.display = 'block';

        if (userRole === 'streamer') {
            captureControls.style.display = 'block';
        }
        
        if (userRole === 'viewer' && isStreaming) {
            console.log("Stream ya está activo. Iniciando visualización...");
            startViewing();
        }
    };

    startButton.onclick = async () => {
        // Deshabilitar el botón temporalmente para evitar clics rápidos
        startButton.disabled = true;
        startButton.textContent = "CARGANDO...";

        try {
            // Liberar el stream anterior y conexiones WebRTC
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                console.log("Stream anterior liberado.");
            }
            Object.values(peerConnections).forEach(pc => pc.close());
            peerConnections = {};

            // Mostrar mensaje para guiar al usuario
            showPlaceholder("Selecciona 'OBS-Camera' o 'OBS Virtual Camera' en el diálogo.");

            // Capturar la cámara virtual de OBS
            localStream = await navigator.mediaDevices.getUserMedia({
                video: true,
                audio: true // Capturar audio si está configurado en OBS
            });
            console.log("Pistas capturadas:", localStream.getVideoTracks(), localStream.getAudioTracks());

            // Verificar si se capturó video
            if (localStream.getVideoTracks().length === 0) {
                showPlaceholder("No se detectó video. Verifica OBS.");
                alert("No se detectó video. Asegúrate de que OBS esté abierto, la cámara virtual esté activada (Tools > VirtualCam > Start), y selecciona 'OBS-Camera'.");
                isStreaming = false;
                startButton.disabled = false;
                startButton.textContent = "INICIAR TRANSMISIÓN";
                return;
            }

            // Asignar el stream al elemento de video para vista previa
            liveStreamVideo.srcObject = localStream;
            liveStreamVideo.muted = true;
            showStream();

            // Ajustar el ancho y la relación de aspecto del contenedor para el streamer
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                const settings = videoTrack.getSettings();
                const width = settings.width;
                const height = settings.height;
                const aspectRatio = width / height;
                console.log(`[Streamer] Resolución capturada: ${width}x${height}, Aspect Ratio: ${aspectRatio}`);
                videoContainer.style.width = `${width}px`; // Ajustar al ancho exacto del stream
                videoContainer.style.aspectRatio = aspectRatio; // Mantener la relación de aspecto
            }

            // Notificar al servidor que el stream ha comenzado
            ws.send(JSON.stringify({ type: 'start_stream', from_id: currentUsername }));

            // Rehabilitar el botón después de 5 segundos
            setTimeout(() => {
                if (isStreaming) {
                    startButton.disabled = false;
                    startButton.textContent = "CAMBIAR FUENTE";
                }
            }, 5000);

            // Listener para cuando el streamer detiene la compartición
            localStream.getVideoTracks()[0].onended = () => {
                console.log("Stream detenido por el usuario");
                ws.send(JSON.stringify({ type: 'stream_ended', from_id: currentUsername }));
                isStreaming = false;
                startButton.disabled = false;
                startButton.textContent = "INICIAR TRANSMISIÓN";
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                Object.values(peerConnections).forEach(pc => pc.close());
                peerConnections = {};
                showPlaceholder("Transmisión finalizada.");
            };
        } catch (err) {
            console.error("Error al capturar la cámara virtual de OBS:", err);
            showPlaceholder("Error al capturar la cámara virtual. Verifica OBS.");
            alert("Error al capturar la cámara virtual. Asegúrate de que OBS esté abierto, la cámara virtual esté activada, y selecciona 'OBS-Camera'.");
            isStreaming = false;
            startButton.disabled = false;
            startButton.textContent = "INICIAR TRANSMISIÓN";
        }
    };

    // LÓGICA DE WEBSOCKET
    function connectWebSocket(username) {
        console.log("Intentando conectar WebSocket...");
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsHost = window.location.host;
        ws = new WebSocket(`${wsProtocol}//${wsHost}/ws/users`);

        let heartbeatInterval;
        let retryCount = 0;
        const maxRetries = 5;

        ws.onopen = () => {
            console.log("Conectado al servidor. WebSocket está en estado OPEN.");
            ws.send(JSON.stringify({ type: "login", name: username }));
            retryCount = 0;

            heartbeatInterval = setInterval(() => {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'ping' }));
                }
            }, 25000);
        };

        ws.onmessage = async (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'pong') return;
                console.log("Mensaje recibido:", data);

                switch (data.type) {
                    case 'login_success':
                        userRole = data.role;
                        streamerId = data.streamer_id || '';
                        console.log(`Rol asignado: ${userRole}, Streamer ID: ${streamerId}`);
                        if (!streamerId && userRole === 'viewer') {
                            console.warn("No se recibió streamer_id. No se puede iniciar visualización.");
                            showPlaceholder("No hay streamer disponible.");
                        }
                        loginContainer.style.display = 'none';
                        welcomeContainer.style.display = 'block';
                        welcomeMessage.textContent = `¡Bienvenido, ${currentUsername}!`;
                        break;

                    case 'stream_started':
                        isStreaming = true;
                        console.log("Stream iniciado. Estado isStreaming:", isStreaming);
                        if (mainContainer.style.display === 'block' && userRole === 'viewer') {
                            showStream();
                            startViewing();
                        }
                        break;
                    
                    case 'stream_ended':
                        isStreaming = false;
                        console.log("Stream finalizado. Estado isStreaming:", isStreaming);
                        showPlaceholder("La transmisión ha finalizado.");
                        if (userRole === 'streamer') {
                            startButton.disabled = false;
                            startButton.textContent = "INICIAR TRANSMISIÓN";
                            if (localStream) localStream.getTracks().forEach(track => track.stop());
                            localStream = null;
                            Object.values(peerConnections).forEach(pc => pc.close());
                            peerConnections = {};
                        } else {
                            if (peerConnection) peerConnection.close();
                            peerConnection = null;
                            liveStreamVideo.srcObject = null;
                        }
                        break;

                    case 'offer':
                        if (userRole === 'streamer') {
                            console.log(`Oferta recibida de ${data.from_id}`);
                            await handleOffer(data.offer, data.from_id);
                        }
                        break;
                    case 'answer':
                        if (userRole === 'viewer') {
                            console.log(`Respuesta recibida de streamer`);
                            await handleAnswer(data.answer, data.from_id);
                        }
                        break;
                    case 'candidate':
                        console.log(`Candidato ICE recibido de ${data.from_id} para ${data.target_id}`);
                        await handleCandidate(data.candidate, data.from_id);
                        break;
                    case 'juego_numero':
                        juegoNumeroElem.textContent = 'Juego Número: ' + data.payload;
                        break;
                    case 'fecha_hora':
                        fechaHoraElem.textContent = 'Fecha y Hora: ' + data.payload;
                        startDateTimeUpdate(data.payload);
                        break;
                    case 'usuarios_conectados':
                        usuariosElem.textContent = `Usuarios conectados: ${data.payload}`;
                        break;
                    default:
                        console.log("Mensaje JSON desconocido:", data);
                }
            } catch (e) {
                console.log("Mensaje de texto plano recibido:", event.data);
                // El mensaje no es JSON, lo tratamos como texto plano
                const messageText = event.data;
                
                // CAMBIO 7: Lógica para habilitar/deshabilitar el botón de apuesta
                if (messageText.trim() === "INICIO del juego") {
                    btnEnviarApuesta.disabled = false;
                    console.log("Apuestas habilitadas.");
                } else if (messageText.trim() === "FIN del juego") {
                    btnEnviarApuesta.disabled = true;
                    console.log("Apuestas deshabilitadas.");
                }
                
                // Mantenemos la lógica existente para otros mensajes de texto
                if (messageText.startsWith("Usuarios conectados:")) {
                    usuariosElem.textContent = messageText;
                } else {
                    const li = document.createElement('li');
                    li.textContent = messageText;
                    messagesElem.appendChild(li);
                }
            }
        };

        ws.onclose = (event) => {
            console.log("Conexión cerrada.", event.code, event.reason);
            // Detener la actualización si el WebSocket se cierra
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
            document.getElementById('fecha_hora').textContent = 'Fecha y Hora: Desconectado';
            document.getElementById('usuarios').textContent = 'Usuarios conectados: 0';
            
            clearInterval(heartbeatInterval);
            ws = null;
            if (retryCount < maxRetries) {
                retryCount++;
                console.log(`Reintentando conexión (${retryCount}/${maxRetries})...`);
                setTimeout(() => connectWebSocket(username), 3000 * retryCount);
            } else {
                loginContainer.style.display = 'block';
                mainContainer.style.display = 'none';
                welcomeContainer.style.display = 'none';
                alert("Se ha perdido la conexión con el servidor. Por favor, recarga la página.");
            }
        };

        ws.onerror = (error) => {
            console.error("Error en WebSocket:", error);
        };
    }

    // LÓGICA DE WEBRTC
    async function startViewing() {
        if (!streamerId) {
            console.error("No se ha recibido el ID del streamer.");
            showPlaceholder("No hay streamer disponible.");
            return;
        }
        try {
            console.log("Iniciando conexión WebRTC como espectador...");
            peerConnection = new RTCPeerConnection(configuration);

            pendingCandidates['viewer'] = [];

            peerConnection.ontrack = (event) => {
                console.log("-> EVENTO ONTRACK DISPARADO");
                const remoteStream = event.streams[0];
                console.log("Pistas de video:", remoteStream.getVideoTracks());
                console.log("Pistas de audio:", remoteStream.getAudioTracks());

                if (liveStreamVideo.srcObject !== remoteStream) {
                    console.log("Asignando nuevo stream al elemento de video.");
                    liveStreamVideo.srcObject = remoteStream;
                }

                liveStreamVideo.muted = true;
                liveStreamVideo.playsInline = true;

                // Ajustar el ancho y la relación de aspecto del contenedor para el espectador
                const videoTrack = remoteStream.getVideoTracks()[0];
                if (videoTrack) {
                    const settings = videoTrack.getSettings();
                    const width = settings.width;
                    const height = settings.height;
                    const aspectRatio = width / height;
                    console.log(`[Viewer] Resolución recibida: ${width}x${height}, Aspect Ratio: ${aspectRatio}`);
                    videoContainer.style.width = `${width}px`; // Ajustar al ancho exacto del stream
                    videoContainer.style.aspectRatio = aspectRatio; // Mantener la relación de aspecto
                }

                console.log("Intentando reproducir el video...");
                const playVideo = () => {
                    liveStreamVideo.play().then(() => {
                        console.log("¡Reproducción iniciada!");
                        showStream();
                    }).catch(error => {
                        console.error("Error al reproducir video:", error);
                        showPlaceholder("Haz clic para reproducir la transmisión.");
                        liveStreamVideo.addEventListener('click', playVideo, { once: true });
                    });
                };
                playVideo();
            };

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Enviando candidato ICE:', event.candidate);
                    ws.send(JSON.stringify({ 
                        type: 'candidate', 
                        candidate: event.candidate,
                        target_id: streamerId,
                        from_id: currentUsername
                    }));
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                console.log("Estado de conexión ICE:", peerConnection.iceConnectionState);
                if (peerConnection.iceConnectionState === 'failed') {
                    console.error("Fallo en la conexión ICE. Verifica el servidor TURN.");
                    showPlaceholder("Error de conexión. Intenta de nuevo.");
                }
            };

            peerConnection.addTransceiver('video', {'direction': 'recvonly'});
            peerConnection.addTransceiver('audio', {'direction': 'recvonly'});
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            console.log("Oferta enviada:", peerConnection.localDescription);
            ws.send(JSON.stringify({ 
                type: 'offer', 
                offer: peerConnection.localDescription, 
                from_id: currentUsername, 
                target_id: streamerId 
            }));
            if (pendingCandidates['viewer'].length > 0) {
                console.log("Procesando candidatos pendientes para viewer...");
                for (const candidate of pendingCandidates['viewer']) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log("Candidato ICE añadido para viewer");
                }
                pendingCandidates['viewer'] = [];
            }
        } catch (error) {
            console.error("Error en startViewing:", error);
            showPlaceholder("Error al conectar con el streamer.");
        }
    }

    async function handleOffer(offer, viewerId) {
        console.log(`Manejando oferta de ${viewerId}`);
        const pc = new RTCPeerConnection(configuration);
        peerConnections[viewerId] = pc;

        pendingCandidates[viewerId] = [];

        pc.onicecandidate = event => {
            if (event.candidate) {
                console.log(`Enviando candidato ICE para ${viewerId}:`, event.candidate);
                ws.send(JSON.stringify({ 
                    type: 'candidate', 
                    candidate: event.candidate,
                    target_id: viewerId,
                    from_id: currentUsername
                }));
            }
        };

        pc.onconnectionstatechange = () => {
            console.log(`Estado de conexión WebRTC para ${viewerId}:`, pc.connectionState);
        };

        try {
            await pc.setRemoteDescription(new RTCSessionDescription(offer));
            console.log(`remoteDescription configurada para ${viewerId}`);
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                    console.log(`Pista añadida para ${viewerId}: ${track.kind} (id: ${track.id})`);
                });
            } else {
                console.error("No hay localStream disponible.");
                return;
            }
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            console.log(`Respuesta enviada para ${viewerId}:`, answer);
            ws.send(JSON.stringify({ 
                type: 'answer', 
                answer: answer,
                target_id: viewerId,
                from_id: currentUsername
            }));
            if (pendingCandidates[viewerId].length > 0) {
                console.log(`Procesando candidatos pendientes para ${viewerId}...`);
                for (const candidate of pendingCandidates[viewerId]) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log(`Candidato ICE añadido para ${viewerId}`);
                }
                pendingCandidates[viewerId] = [];
            }
        } catch (error) {
            console.error(`Error manejando oferta de ${viewerId}:`, error);
        }
    }

    async function handleAnswer(answer, fromId) {
        const pc = peerConnection;
        if (pc) {
            try {
                await pc.setRemoteDescription(new RTCSessionDescription(answer));
                console.log(`remoteDescription configurada para respuesta de ${fromId}`);
                if (pendingCandidates['viewer'].length > 0) {
                    console.log(`Procesando candidatos pendientes para viewer...`);
                    for (const candidate of pendingCandidates['viewer']) {
                        await pc.addIceCandidate(new RTCIceCandidate(candidate));
                        console.log(`Candidato ICE añadido para viewer`);
                    }
                    pendingCandidates['viewer'] = [];
                }
            } catch (error) {
                console.error(`Error manejando respuesta de ${fromId}:`, error);
            }
        } else {
            console.warn(`No se encontró peerConnection para el viewer`);
        }
    }

    async function handleCandidate(candidate, fromId) {
        const pc = (userRole === 'streamer') ? peerConnections[fromId] : peerConnection;
        if (pc) {
            try {
                if (pc.remoteDescription && pc.remoteDescription.type) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log(`Candidato ICE añadido para ${fromId}`);
                } else {
                    console.log(`remoteDescription no está lista para ${fromId}. Almacenando candidato...`);
                    if (!pendingCandidates[fromId] && userRole === 'streamer') {
                        pendingCandidates[fromId] = [];
                    } else if (!pendingCandidates['viewer'] && userRole === 'viewer') {
                        pendingCandidates['viewer'] = [];
                    }
                    (userRole === 'streamer' ? pendingCandidates[fromId] : pendingCandidates['viewer']).push(candidate);
                }
            } catch (e) {
                console.error(`Error añadiendo candidato ICE para ${fromId}:`, e);
            }
        } else {
            console.warn(`No se encontró peerConnection para ${fromId}`);
        }
    }

    // Funciones de UI
    function showStream() {
        liveStreamVideo.style.visibility = 'visible';
        streamPlaceholder.style.display = 'none';
    }

    function showPlaceholder(message) {
        liveStreamVideo.style.visibility = 'hidden';
        streamPlaceholder.textContent = message;
        streamPlaceholder.style.display = 'block';
    }
</script>
</body>
</html>
-->


<!DOCTYPE html>
<html>
<head>
    <title>Ruleta Americana - WebRTC P2P</title>
    <style>
        body { 
            font-family: sans-serif; 
            margin: 0; 
            padding: 0; 
        }
        #main-container, #capture-controls { display: none; }
        #login-container { text-align: center; margin-top: 50px; }
        .video-container {
            width: 50%;
            background-color: #000;
            position: relative;
            box-sizing: border-box;
        }
        #live-stream {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
            image-rendering: pixelated;
        }
        .video-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
            font-size: 1.5em;
            text-align: center;
        }
        #welcome-container {
            display: none;
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        #enter-game-button {
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        #enter-game-button:hover {
            background-color: #0056b3;
        }
        #tutorial-video {
            width: 50%;
            height: auto;
        }
    </style>
</head>
<body>
    <div id="login-container">
        <h1>Bienvenido a la Ruleta Americana</h1>
        <p>Por favor, ingresa tu nombre para continuar.</p>
        <form id="login-form">
            <input type="text" id="name-input" placeholder="Tu nombre" required>
            <button type="submit">Ingresar</button>
        </form>
    </div>
    <div id="welcome-container">
        <h1 id="welcome-message"></h1>
        <p>¡Todo listo para empezar!</p>
        <video id="tutorial-video" src="/static/color_wheel.mp4" controls></video>
        <button id="enter-game-button">ENTRAR AL JUEGO</button>
    </div>
    <div id="main-container">
        <h1>Ruleta Americana (Stream en Vivo - WebRTC)</h1>
        <div class="video-container">
            <video id="live-stream" autoplay muted playsinline></video>
            <div id="streamPlaceholder" class="video-placeholder">Esperando transmisión...</div>
        </div>
        <div id="capture-controls">
            <button id="startButton">INICIAR TRANSMISIÓN</button>
        </div>
        <br>
        <p id="fecha_hora">Fecha y Hora: Esperando...</p>
        <p id="juego_numero">Juego Número: Esperando...</p>
        <p id="usuarios">Usuarios conectados: 0</p>
        <h1>Realiza tu apuesta</h1>
        <form onsubmit="sendMessage(event)">
            <label>Jugador: <strong id="nombre-logueado"></strong></label>
            <br><br>
            <input type="number" id="apuesta" placeholder="Número de apuesta" autocomplete="off" min="0" max="36" required/>
            <button id="btnEnviarApuesta" disabled>Enviar</button>
        </form>
        <ul id="messages"></ul>
    </div>

<script>
    // Referencias al DOM
    const loginContainer = document.getElementById('login-container');
    const mainContainer = document.getElementById('main-container');
    const loginForm = document.getElementById('login-form');
    const nameInput = document.getElementById('name-input');
    const startButton = document.getElementById('startButton');
    const captureControls = document.getElementById('capture-controls');
    const liveStreamVideo = document.getElementById('live-stream');
    const streamPlaceholder = document.getElementById('streamPlaceholder');
    
    const fechaHoraElem = document.getElementById('fecha_hora');
    const juegoNumeroElem = document.getElementById('juego_numero');
    const usuariosElem = document.getElementById('usuarios');
    const messagesElem = document.getElementById('messages');
    
    const nombreLogueadoElem = document.getElementById('nombre-logueado');
    const btnEnviarApuesta = document.getElementById('btnEnviarApuesta');
    
    const welcomeContainer = document.getElementById('welcome-container');
    const welcomeMessage = document.getElementById('welcome-message');
    const enterGameButton = document.getElementById('enter-game-button');
    const videoContainer = document.querySelector('.video-container');
    
    // Estado Global y Configuración
    let ws = null;
    let userRole = "viewer";
    let isStreaming = false;
    let localStream;
    let peerConnections = {};
    let peerConnection;
    let currentUsername = '';
    let streamerId = '';
    const pendingCandidates = {};
    let intervalId = null;
    let currentDateTime = null;
    
	/*
    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            {
                urls: 'turn:relay1.expressturn.com:3480',
                username: '000000002067441357',
                credential: 'ZWtqCZGCwebs2UeE8c8ryeqBHN8='
            }
        ]
    };
    */
	
	const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            {
                urls: 'turn:relay1.expressturn.com:3480',
                username: '000000002067654307',
                credential: '1jzG+9wsEaf0vTCLYDavBWY/TC4='
            }
        ]
    };
	
    // Función para actualizar la fecha y hora cada segundo
    function startDateTimeUpdate(fechaHoraStr) {
        if (intervalId) {
            clearInterval(intervalId);
        }
        const [datePart, timePart] = fechaHoraStr.split(' ');
        const [day, month, year] = datePart.split('-').map(Number);
        const [hours, minutes, seconds] = timePart.split(':').map(Number);
        currentDateTime = new Date(year, month - 1, day, hours, minutes, seconds);
        intervalId = setInterval(() => {
            currentDateTime.setSeconds(currentDateTime.getSeconds() + 1);
            const formattedDateTime = `Fecha: ${currentDateTime.getDate().toString().padStart(2, '0')}/${(currentDateTime.getMonth() + 1).toString().padStart(2, '0')}/${currentDateTime.getFullYear()}\nHora: ${currentDateTime.getHours().toString().padStart(2, '0')}:${currentDateTime.getMinutes().toString().padStart(2, '0')}:${currentDateTime.getSeconds().toString().padStart(2, '0')}`;
            fechaHoraElem.textContent = formattedDateTime;
        }, 1000);
    }
        
    // INICIO DEL FLUJO DE LA APLICACIÓN
    loginForm.onsubmit = (event) => {
        event.preventDefault();
        const username = nameInput.value.trim();
        if (username) {
            if (!ws || ws.readyState === WebSocket.CLOSED) {
                currentUsername = username;
                connectWebSocket(username);
            } else {
                console.log("Ya se está intentando una conexión.");
            }
        } else {
            alert("Por favor, ingresa un nombre.");
        }
    };

    enterGameButton.onclick = () => {
        console.log("Usuario ha entrado al juego. Mostrando contenedor principal.");
        welcomeContainer.style.display = 'none';
        mainContainer.style.display = 'block';
        if (userRole === 'streamer') {
            captureControls.style.display = 'block';
        }
        if (userRole === 'viewer' && isStreaming) {
            console.log("Stream ya está activo. Iniciando visualización...");
            startViewing();
        }
    };

    startButton.onclick = async () => {
        startButton.disabled = true;
        startButton.textContent = "CARGANDO...";
        try {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                console.log("Stream anterior liberado.");
            }
            Object.values(peerConnections).forEach(pc => pc.close());
            peerConnections = {};
            showPlaceholder("Selecciona 'OBS-Camera' o 'OBS Virtual Camera' en el diálogo.");
            localStream = await navigator.mediaDevices.getUserMedia({
                video: true,
                audio: true
            });
            console.log("Pistas capturadas:", localStream.getVideoTracks(), localStream.getAudioTracks());
            if (localStream.getVideoTracks().length === 0) {
                showPlaceholder("No se detectó video. Verifica OBS.");
                alert("No se detectó video. Asegúrate de que OBS esté abierto, la cámara virtual esté activada (Tools > VirtualCam > Start), y selecciona 'OBS-Camera'.");
                isStreaming = false;
                startButton.disabled = false;
                startButton.textContent = "INICIAR TRANSMISIÓN";
                return;
            }
            liveStreamVideo.srcObject = localStream;
            liveStreamVideo.muted = true;
            showStream();
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                const settings = videoTrack.getSettings();
                const width = settings.width;
                const height = settings.height;
                const aspectRatio = width / height;
                console.log(`[Streamer] Resolución capturada: ${width}x${height}, Aspect Ratio: ${aspectRatio}`);
                videoContainer.style.width = `${width}px`;
                videoContainer.style.aspectRatio = aspectRatio;
            }
            ws.send(JSON.stringify({ type: 'start_stream', from_id: currentUsername }));
            setTimeout(() => {
                if (isStreaming) {
                    startButton.disabled = false;
                    startButton.textContent = "CAMBIAR FUENTE";
                }
            }, 5000);
            localStream.getVideoTracks()[0].onended = () => {
                console.log("Stream detenido por el usuario");
                ws.send(JSON.stringify({ type: 'stream_ended', from_id: currentUsername }));
                isStreaming = false;
                startButton.disabled = false;
                startButton.textContent = "INICIAR TRANSMISIÓN";
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                Object.values(peerConnections).forEach(pc => pc.close());
                peerConnections = {};
                showPlaceholder("Transmisión finalizada.");
            };
        } catch (err) {
            console.error("Error al capturar la cámara virtual de OBS:", err);
            showPlaceholder("Error al capturar la cámara virtual. Verifica OBS.");
            alert("Error al capturar la cámara virtual. Asegúrate de que OBS esté abierto, la cámara virtual esté activada, y selecciona 'OBS-Camera'.");
            isStreaming = false;
            startButton.disabled = false;
            startButton.textContent = "INICIAR TRANSMISIÓN";
        }
    };
	
	
	
    // LÓGICA DE WEBSOCKET
    function connectWebSocket(username) {
        console.log("Intentando conectar WebSocket...");
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsHost = window.location.host;
        ws = new WebSocket(`${wsProtocol}//${wsHost}/ws/users`);

        let heartbeatInterval;
        let retryCount = 0;
        const maxRetries = 5;

        ws.onopen = () => {
            console.log("Conectado al servidor. WebSocket está en estado OPEN.");
            ws.send(JSON.stringify({ type: "login", name: username }));
            retryCount = 0;
            heartbeatInterval = setInterval(() => {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'ping' }));
                }
            }, 10000);
        };

        ws.onmessage = async (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'pong') return;
                console.log("Mensaje recibido:", data);

                switch (data.type) {
                    case 'login_success':
                        userRole = data.role;
                        streamerId = data.streamer_id || '';
                        console.log(`Rol asignado: ${userRole}, Streamer ID: ${streamerId}`);
                        if (!streamerId && userRole === 'viewer') {
                            console.warn("No se recibió streamer_id. No se puede iniciar visualización.");
                            showPlaceholder("No hay streamer disponible.");
                        }
                        loginContainer.style.display = 'none';
                        welcomeContainer.style.display = 'block';
                        welcomeMessage.textContent = `¡Bienvenido, ${currentUsername}!`;
                        break;

                    case 'stream_started':
                        isStreaming = true;
                        console.log("Stream iniciado. Estado isStreaming:", isStreaming);
                        if (mainContainer.style.display === 'block' && userRole === 'viewer') {
                            showStream();
                            startViewing();
                        }
                        break;
                    
                    case 'stream_ended':
                        isStreaming = false;
                        console.log("Stream finalizado. Estado isStreaming:", isStreaming);
                        showPlaceholder("La transmisión ha finalizado.");
                        if (userRole === 'streamer') {
                            startButton.disabled = false;
                            startButton.textContent = "INICIAR TRANSMISIÓN";
                            if (localStream) localStream.getTracks().forEach(track => track.stop());
                            localStream = null;
                            Object.values(peerConnections).forEach(pc => pc.close());
                            peerConnections = {};
                        } else {
                            if (peerConnection) peerConnection.close();
                            peerConnection = null;
                            liveStreamVideo.srcObject = null;
                        }
                        break;

                    case 'offer':
                        if (userRole === 'streamer') {
                            console.log(`Oferta recibida de ${data.from_id}`);
                            await handleOffer(data.offer, data.from_id);
                        }
                        break;
                    case 'answer':
                        if (userRole === 'viewer') {
                            console.log(`Respuesta recibida de streamer`);
                            await handleAnswer(data.answer, data.from_id);
                        }
                        break;
                    case 'candidate':
                        console.log(`Candidato ICE recibido de ${data.from_id} para ${data.target_id}`);
                        await handleCandidate(data.candidate, data.from_id);
                        break;
                    case 'fecha_hora':
						console.log(`Recibido un cambio en fecha_hora ${data.payload}`);
                        fechaHoraElem.textContent = 'Fecha y Hora: ' + data.payload;
                        startDateTimeUpdate(data.payload);
                        break;
                    case 'juego_numero':
                        juegoNumeroElem.textContent = `Juego Número: ${data.payload}`;
                        break;
                    case 'usuarios_conectados':
                        usuariosElem.textContent = `Usuarios conectados: ${data.payload}`;
                        break;
                    default:
                        console.log("Mensaje JSON desconocido:", data);
                }
            } catch (e) {
                console.error("Error al parsear mensaje WebSocket:", e);
                console.log("Mensaje recibido (texto plano):", event.data);
                const messageText = String(event.data).trim();
                if (messageText === "INICIO del juego") {
                    btnEnviarApuesta.disabled = false;
                    console.log("Apuestas habilitadas.");
                } else if (messageText === "FIN del juego") {
                    btnEnviarApuesta.disabled = true;
                    console.log("Apuestas deshabilitadas.");
                } else if (messageText.startsWith("Usuarios conectados:")) {
                    usuariosElem.textContent = messageText;
                } else {
                    const li = document.createElement('li');
                    li.textContent = messageText;
                    messagesElem.appendChild(li);
                }
            }
        };

        ws.onclose = (event) => {
            console.log(`Conexión cerrada. Código: ${event.code}, Razón: ${event.reason}`);
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
            fechaHoraElem.textContent = 'Fecha y Hora: Desconectado';
            usuariosElem.textContent = 'Usuarios conectados: 0';
            clearInterval(heartbeatInterval);
            ws = null;
            if (retryCount < maxRetries) {
                retryCount++;
                const delay = 3000 * retryCount + (Math.random() * 100);
                console.log(`Reintentando conexión (${retryCount}/${maxRetries}) en ${delay}ms...`);
                setTimeout(() => connectWebSocket(username), delay);
            } else {
                loginContainer.style.display = 'block';
                mainContainer.style.display = 'none';
                welcomeContainer.style.display = 'none';
                alert("Se ha perdido la conexión con el servidor. Por favor, recarga la página.");
            }
        };

        ws.onerror = (error) => {
            console.error("Error en WebSocket:", error);
        };
    }

    // LÓGICA DE WEBRTC
	/*
    async function startViewing() {
        if (!streamerId) {
            console.error("No se ha recibido el ID del streamer.");
            showPlaceholder("No hay streamer disponible.");
            return;
        }
        try {
            console.log("Iniciando conexión WebRTC como espectador...");
            peerConnection = new RTCPeerConnection(configuration);
            pendingCandidates['viewer'] = [];
            peerConnection.ontrack = (event) => {
                console.log("-> EVENTO ONTRACK DISPARADO");
                const remoteStream = event.streams[0];
                console.log("Pistas de video:", remoteStream.getVideoTracks());
                console.log("Pistas de audio:", remoteStream.getAudioTracks());
                if (liveStreamVideo.srcObject !== remoteStream) {
                    console.log("Asignando nuevo stream al elemento de video.");
                    liveStreamVideo.srcObject = remoteStream;
                }
                liveStreamVideo.muted = true;
                liveStreamVideo.playsInline = true;
                const videoTrack = remoteStream.getVideoTracks()[0];
                if (videoTrack) {
                    const settings = videoTrack.getSettings();
                    const width = settings.width;
                    const height = settings.height;
                    const aspectRatio = width / height;
                    console.log(`[Viewer] Resolución recibida: ${width}x${height}, Aspect Ratio: ${aspectRatio}`);
                    videoContainer.style.width = `${width}px`;
                    videoContainer.style.aspectRatio = aspectRatio;
                }
                console.log("Intentando reproducir el video...");
                const playVideo = () => {
                    liveStreamVideo.play().then(() => {
                        console.log("¡Reproducción iniciada!");
                        showStream();
                    }).catch(error => {
                        console.error("Error al reproducir video:", error);
                        showPlaceholder("Haz clic para reproducir la transmisión.");
                        liveStreamVideo.addEventListener('click', playVideo, { once: true });
                    });
                };
                playVideo();
            };
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Enviando candidato ICE:', event.candidate);
                    ws.send(JSON.stringify({ 
                        type: 'candidate', 
                        candidate: event.candidate,
                        target_id: streamerId,
                        from_id: currentUsername
                    }));
                }
            };
            peerConnection.oniceconnectionstatechange = () => {
                console.log("Estado de conexión ICE:", peerConnection.iceConnectionState);
                if (peerConnection.iceConnectionState === 'failed') {
                    console.error("Fallo en la conexión ICE. Detalles:", {
                        iceConnectionState: peerConnection.iceConnectionState,
                        iceGatheringState: peerConnection.iceGatheringState,
                        signalingState: peerConnection.signalingState
                    });
                    showPlaceholder("Error de conexión WebRTC. Intenta de nuevo.");
                    peerConnection.restartIce();
                }
            };
            peerConnection.addTransceiver('video', {'direction': 'recvonly'});
            peerConnection.addTransceiver('audio', {'direction': 'recvonly'});
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            console.log("Oferta enviada:", offer);
            ws.send(JSON.stringify({ 
                type: 'offer', 
                offer: { type: offer.type, sdp: offer.sdp }, 
                from_id: currentUsername, 
                target_id: streamerId 
            }));
            if (pendingCandidates['viewer'].length > 0) {
                console.log("Procesando candidatos pendientes para viewer...");
                for (const candidate of pendingCandidates['viewer']) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log("Candidato ICE añadido para viewer");
                }
                pendingCandidates['viewer'] = [];
            }
        } catch (error) {
            console.error("Error en startViewing:", error);
            showPlaceholder("Error al conectar con el streamer.");
        }
    }
	*/
	
	/*
    async function startViewing() {
        if (!streamerId) {
            console.error("No se ha recibido el ID del streamer.");
            showPlaceholder("No hay streamer disponible.");
            return;
        }
        try {
            console.log("Iniciando conexión WebRTC como espectador...");
            peerConnection = new RTCPeerConnection(configuration);
            pendingCandidates['viewer'] = [];

            peerConnection.ontrack = (event) => {
                console.log("Recibiendo pista de video...");
                console.log("Pistas de video:", event.streams[0].getVideoTracks());
                console.log("Pistas de audio:", event.streams[0].getAudioTracks());
                liveStreamVideo.srcObject = event.streams[0];
                showStream();

                // Intentar obtener la resolución desde la pista de video
                const videoTrack = event.streams[0].getVideoTracks()[0];
                if (videoTrack) {
                    const checkResolution = () => {
                        const settings = videoTrack.getSettings();
                        const width = settings.width || 640; // Fallback a 640 si no hay metadatos
                        const height = settings.height || 480; // Fallback a 480
                        const aspectRatio = width / height;
                        console.log(`[Viewer] Resolución recibida: ${width}x${height}, Aspect Ratio: ${aspectRatio}`);
                        
                        // Ajustar el contenedor de video
                        videoContainer.style.width = `${Math.min(window.innerWidth - 40, width)}px`;
                        videoContainer.style.height = `${Math.min(window.innerWidth - 40, width) / aspectRatio}px`;
                        videoContainer.style.aspectRatio = aspectRatio;

                        // Intentar reproducir el video
                        console.log("Intentando reproducir el video...");
                        liveStreamVideo.play().catch(err => {
                            console.error("Error al reproducir el video:", err);
                            showPlaceholder("Error al reproducir el video. Verifica la conexión.");
                        });
                    };

                    // Verificar metadatos inmediatamente y reintentar si no están disponibles
                    const tryMetadata = () => {
                        if (videoTrack.getSettings().width && videoTrack.getSettings().height) {
                            checkResolution();
                        } else {
                            console.log("Metadatos no disponibles, reintentando...");
                            setTimeout(tryMetadata, 100); // Reintentar cada 100ms
                        }
                    };
                    tryMetadata();
                } else {
                    console.error("No se encontraron pistas de video.");
                    showPlaceholder("No se encontraron pistas de video.");
                }

                liveStreamVideo.onerror = (err) => {
                    console.error("Error en el elemento de video:", err);
                    showPlaceholder("Error al cargar el video. Verifica la fuente.");
                };
            };

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Enviando candidato ICE:', event.candidate);
                    ws.send(JSON.stringify({ 
                        type: 'candidate', 
                        candidate: event.candidate,
                        target_id: streamerId,
                        from_id: currentUsername
                    }));
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                console.log("Estado de conexión ICE:", peerConnection.iceConnectionState);
                if (peerConnection.iceConnectionstate === 'failed') {
                    console.error("Fallo en la conexión ICE. Reintentando...");
                    peerConnection.restartIce();
                }
            };

            peerConnection.addTransceiver('video', {'direction': 'recvonly'});
            peerConnection.addTransceiver('audio', {'direction': 'recvonly'});
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            console.log("Oferta enviada:", offer);
            ws.send(JSON.stringify({ 
                type: 'offer', 
                offer: { type: offer.type, sdp: offer.sdp }, 
                from_id: currentUsername, 
                target_id: streamerId 
            }));
            if (pendingCandidates['viewer'].length > 0) {
                console.log("Procesando candidatos pendientes para viewer...");
                for (const candidate of pendingCandidates['viewer']) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log("Candidato ICE añadido para viewer");
                }
                pendingCandidates['viewer'] = [];
            }
        } catch (error) {
            console.error("Error en startViewing:", error);
            showPlaceholder("Error al conectar con el streamer.");
        }
    }
	*/
	
	const MAX_METADATA_RETRIES = 50; // Máximo de 50 reintentos (~5 segundos)

    async function startViewing() {
            if (!streamerId) {
                console.error("No se ha recibido el ID del streamer.");
                showPlaceholder("No hay streamer disponible.");
                return;
            }
            if (!liveStreamVideo || !videoContainer) {
                console.error("Elementos de video o contenedor no encontrados en el DOM.");
                showPlaceholder("Error: Elemento de video no encontrado.");
                return;
            }
            try {
                console.log("Iniciando conexión WebRTC como espectador...");
                peerConnection = new RTCPeerConnection(configuration);
                pendingCandidates['viewer'] = [];

                peerConnection.ontrack = (event) => {
                    console.log("-> EVENTO ONTRACK DISPARADO");
                    console.log("Pistas de video:", event.streams[0].getVideoTracks());
                    console.log("Pistas de audio:", event.streams[0].getAudioTracks());
                    liveStreamVideo.srcObject = event.streams[0];
                    showStream();

                    // Intentar reproducir el video inmediatamente
                    console.log("Intentando reproducir el video...");
                    liveStreamVideo.play().catch(err => {
                        console.error("Error al reproducir el video:", err);
                        showPlaceholder("Error al reproducir el video. Verifica la conexión.");
                    });

                    const videoTrack = event.streams[0].getVideoTracks()[0];
                    if (videoTrack) {
                        let retryCount = 0;
                        const tryMetadata = () => {
                            const settings = videoTrack.getSettings();
                            if (settings.width && settings.height) {
                                const width = settings.width;
                                const height = settings.height;
                                const aspectRatio = width / height;
                                console.log(`[Viewer] Resolución recibida: ${width}x${height}, Aspect Ratio: ${aspectRatio}`);
                                videoContainer.style.width = `${Math.min(window.innerWidth - 40, width)}px`;
                                videoContainer.style.height = `${Math.min(window.innerWidth - 40, width) / aspectRatio}px`;
                                videoContainer.style.aspectRatio = aspectRatio;
                            } else if (retryCount < MAX_METADATA_RETRIES) {
                                console.log("Metadatos no disponibles, reintentando...");
                                retryCount++;
                                setTimeout(tryMetadata, 100);
                            } else {
                                console.error("No se pudieron obtener los metadatos después de varios intentos.");
                                videoContainer.style.width = '640px';
                                videoContainer.style.height = '480px';
                                videoContainer.style.aspectRatio = 640 / 480;
                            }
                        };
                        tryMetadata();
                    } else {
                        console.error("No se encontraron pistas de video.");
                        showPlaceholder("No se encontraron pistas de video.");
                    }
                };

                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log('Enviando candidato ICE:', event.candidate);
                        ws.send(JSON.stringify({ 
                            type: 'candidate', 
                            candidate: event.candidate,
                            target_id: streamerId,
                            from_id: currentUsername
                        }));
                    }
                };

                peerConnection.oniceconnectionstatechange = () => {
                    console.log("Estado de conexión ICE:", peerConnection.iceConnectionState);
                    if (peerConnection.iceConnectionState === 'failed') {
                        console.error("Fallo en la conexión ICE. Reintentando...");
                        peerConnection.restartIce();
                    }
                };

                peerConnection.addTransceiver('video', {'direction': 'recvonly'});
                peerConnection.addTransceiver('audio', {'direction': 'recvonly'});
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                console.log("Oferta enviada:", offer);
                ws.send(JSON.stringify({ 
                    type: 'offer', 
                    offer: { type: offer.type, sdp: offer.sdp }, 
                    from_id: currentUsername, 
                    target_id: streamerId 
                }));
            } catch (error) {
                console.error("Error en startViewing:", error);
                showPlaceholder("Error al conectar con el streamer.");
            }
        }
    async function handleOffer(offer, viewerId) {
        console.log(`Manejando oferta de ${viewerId}`);
        const pc = new RTCPeerConnection(configuration);
        peerConnections[viewerId] = pc;
        pendingCandidates[viewerId] = [];
        pc.onicecandidate = event => {
            if (event.candidate) {
                console.log(`Enviando candidato ICE para ${viewerId}:`, event.candidate);
                ws.send(JSON.stringify({ 
                    type: 'candidate', 
                    candidate: event.candidate,
                    target_id: viewerId,
                    from_id: currentUsername
                }));
            }
        };
        pc.onconnectionstatechange = () => {
            console.log(`Estado de conexión WebRTC para ${viewerId}:`, pc.connectionState);
            if (pc.connectionState === 'failed') {
                console.error("Fallo en conexión WebRTC para", viewerId, {
                    iceConnectionState: pc.iceConnectionState,
                    iceGatheringState: pc.iceGatheringState,
                    signalingState: pc.signalingState
                });
            }
        };
        try {
            // Ensure SDP is a valid string
            if (!offer || !offer.sdp || typeof offer.sdp !== 'string') {
                throw new Error(`Invalid SDP in offer from ${viewerId}`);
            }
            await pc.setRemoteDescription(new RTCSessionDescription(offer));
            console.log(`remoteDescription configurada para ${viewerId}`);
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                    console.log(`Pista añadida para ${viewerId}: ${track.kind} (id: ${track.id})`);
                });
            } else {
                console.error("No hay localStream disponible.");
                return;
            }
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            console.log(`Respuesta enviada para ${viewerId}:`, answer);
            ws.send(JSON.stringify({ 
                type: 'answer', 
                answer: { type: answer.type, sdp: answer.sdp },
                target_id: viewerId,
                from_id: currentUsername
            }));
            if (pendingCandidates[viewerId].length > 0) {
                console.log(`Procesando candidatos pendientes para ${viewerId}...`);
                for (const candidate of pendingCandidates[viewerId]) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log(`Candidato ICE añadido para ${viewerId}`);
                }
                pendingCandidates[viewerId] = [];
            }
        } catch (error) {
            console.error(`Error manejando oferta de ${viewerId}:`, error);
        }
    }

    async function handleAnswer(answer, fromId) {
        const pc = peerConnection;
        if (pc) {
            try {
                // Ensure SDP is a valid string
                if (!answer || !answer.sdp || typeof answer.sdp !== 'string') {
                    throw new Error(`Invalid SDP in answer from ${fromId}`);
                }
                await pc.setRemoteDescription(new RTCSessionDescription(answer));
                console.log(`remoteDescription configurada para respuesta de ${fromId}`);
                if (pendingCandidates['viewer'].length > 0) {
                    console.log(`Procesando candidatos pendientes para viewer...`);
                    for (const candidate of pendingCandidates['viewer']) {
                        await pc.addIceCandidate(new RTCIceCandidate(candidate));
                        console.log(`Candidato ICE añadido para viewer`);
                    }
                    pendingCandidates['viewer'] = [];
                }
            } catch (error) {
                console.error(`Error manejando respuesta de ${fromId}:`, error);
            }
        } else {
            console.warn(`No se encontró peerConnection para el viewer`);
        }
    }

    async function handleCandidate(candidate, fromId) {
        const pc = (userRole === 'streamer') ? peerConnections[fromId] : peerConnection;
        if (pc) {
            try {
                // Validate candidate before processing
                if (!candidate || (!candidate.candidate && candidate.candidate !== '')) {
                    console.warn(`Candidato ICE inválido de ${fromId}:`, candidate);
                    return;
                }
                if (pc.remoteDescription && pc.remoteDescription.type) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log(`Candidato ICE añadido para ${fromId}`);
                } else {
                    console.log(`remoteDescription no está lista para ${fromId}. Almacenando candidato...`);
                    if (!pendingCandidates[fromId] && userRole === 'streamer') {
                        pendingCandidates[fromId] = [];
                    } else if (!pendingCandidates['viewer'] && userRole === 'viewer') {
                        pendingCandidates['viewer'] = [];
                    }
                    (userRole === 'streamer' ? pendingCandidates[fromId] : pendingCandidates['viewer']).push(candidate);
                }
            } catch (e) {
                console.error(`Error añadiendo candidato ICE para ${fromId}:`, e);
            }
        } else {
            console.warn(`No se encontró peerConnection para ${fromId}`);
        }
    }

    // Funciones de UI
    function showStream() {
        liveStreamVideo.style.visibility = 'visible';
        streamPlaceholder.style.display = 'none';
    }

    function showPlaceholder(message) {
        liveStreamVideo.style.visibility = 'hidden';
        streamPlaceholder.textContent = message;
        streamPlaceholder.style.display = 'block';
    }

    // Función para enviar mensajes de apuesta
    function sendMessage(event) {
        event.preventDefault();
        const apuestaInput = document.getElementById('apuesta');
        const apuesta = apuestaInput.value;
        if (apuesta && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(`Apuesta de ${currentUsername}: ${apuesta}`);
            apuestaInput.value = '';
        } else {
            console.warn("WebSocket no está abierto o apuesta vacía.");
        }
    }
</script>
</body>
</html>

